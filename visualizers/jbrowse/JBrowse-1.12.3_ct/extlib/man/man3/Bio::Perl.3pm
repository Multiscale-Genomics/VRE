.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Perl 3"
.TH Bio::Perl 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Perl \- Functional access to BioPerl for people who don't know objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::Perl;
\&
\&  # will guess file format from extension
\&  $seq_object = read_sequence($filename);
\&
\&  # forces genbank format
\&  $seq_object = read_sequence($filename,\*(Aqgenbank\*(Aq);
\&
\&  # reads an array of sequences
\&  @seq_object_array = read_all_sequences($filename,\*(Aqfasta\*(Aq);
\&
\&  # sequences are Bio::Seq objects, so the following methods work
\&  # for more info see Bio::Seq, or do \*(Aqperldoc Bio/Seq.pm\*(Aq
\&
\&  print "Sequence name is ",$seq_object\->display_id,"\en";
\&  print "Sequence acc  is ",$seq_object\->accession_number,"\en";
\&  print "First 5 bases is ",$seq_object\->subseq(1,5),"\en";
\&
\&  # get the whole sequence as a single string
\&
\&  $sequence_as_a_string = $seq_object\->seq();
\&
\&  # writing sequences
\&
\&  write_sequence(">$filename",\*(Aqgenbank\*(Aq,$seq_object);
\&
\&  write_sequence(">$filename",\*(Aqgenbank\*(Aq,@seq_object_array);
\&
\&  # making a new sequence from just a string
\&
\&  $seq_object = new_sequence("ATTGGTTTGGGGACCCAATTTGTGTGTTATATGTA",
\&      "myname","AL12232");
\&
\&  # getting a sequence from a database (assumes internet connection)
\&
\&  $seq_object = get_sequence(\*(Aqswissprot\*(Aq,"ROA1_HUMAN");
\&
\&  $seq_object = get_sequence(\*(Aqembl\*(Aq,"AI129902");
\&
\&  $seq_object = get_sequence(\*(Aqgenbank\*(Aq,"AI129902");
\&
\&  # BLAST a sequence (assumes an internet connection)
\&
\&  $blast_report = blast_sequence($seq_object);
\&
\&  write_blast(">blast.out",$blast_report);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Easy first time access to BioPerl via functions.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 1
\&  bioperl\-l@bioperl.org
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Ewan Birney"
.IX Header "AUTHOR - Ewan Birney"
Email birney@ebi.ac.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "read_sequence"
.IX Subsection "read_sequence"
.Vb 3
\& Title   : read_sequence
\& Usage   : $seq = read_sequence(\*(Aqsequences.fa\*(Aq)
\&           $seq = read_sequence($filename,\*(Aqgenbank\*(Aq);
\&
\&           # pipes are fine
\&           $seq = read_sequence("my_fetching_program $id |",\*(Aqfasta\*(Aq);
\&
\& Function: Reads the top sequence from the file. If no format is given, it will
\&           try to guess the format from the filename. If a format is given, it
\&           forces that format. The filename can be any valid perl open() string
\&           \- in particular, you can put in pipes
\&
\& Returns : A Bio::Seq object. A quick synopsis:
\&           $seq_object\->display_id \- name of the sequence
\&           $seq_object\->seq        \- sequence as a string
\&
\& Args    : Two strings, first the filename \- any Perl open() string is ok
\&           Second string is the format, which is optional
.Ve
.PP
For more information on Seq objects see Bio::Seq.
.SS "read_all_sequences"
.IX Subsection "read_all_sequences"
.Vb 3
\& Title   : read_all_sequences
\& Usage   : @seq_object_array = read_all_sequences($filename);
\&           @seq_object_array = read_all_sequences($filename,\*(Aqgenbank\*(Aq);
\&
\& Function: Just as the function above, but reads all the sequences in the
\&           file and loads them into an array.
\&
\&           For very large files, you will run out of memory. When this
\&           happens, you\*(Aqve got to use the SeqIO system directly (this is
\&           not so hard! Don\*(Aqt worry about it!).
\&
\& Returns : array of Bio::Seq objects
\&
\& Args    : two strings, first the filename (any open() string is ok)
\&           second the format (which is optional)
.Ve
.PP
See Bio::SeqIO and Bio::Seq for more information
.SS "write_sequence"
.IX Subsection "write_sequence"
.Vb 3
\& Title   : write_sequence
\& Usage   : write_sequence(">new_file.gb",\*(Aqgenbank\*(Aq,$seq)
\&           write_sequence(">new_file.gb",\*(Aqgenbank\*(Aq,@array_of_sequence_objects)
\&
\& Function: writes sequences in the specified format
\&
\& Returns : true
\&
\& Args    : filename as a string, must provide an open() output file
\&           format as a string
\&           one or more sequence objects
.Ve
.SS "new_sequence"
.IX Subsection "new_sequence"
.Vb 2
\& Title   : new_sequence
\& Usage   : $seq_obj = new_sequence("GATTACA", "kino\-enzyme");
\&
\& Function: Construct a sequency object from sequence string
\& Returns : A Bio::Seq object
\&
\& Args    : sequence string
\&           name string (optional, default "no\-name\-for\-sequence")
\&           accession \- accession number (optional, no default)
.Ve
.SS "blast_sequence"
.IX Subsection "blast_sequence"
.Vb 3
\& Title   : blast_sequence
\& Usage   : $blast_result = blast_sequence($seq)
\&           $blast_result = blast_sequence(\*(AqMFVEGGTFASEDDDSASAEDE\*(Aq);
\&
\& Function: If the computer has Internet accessibility, blasts
\&           the sequence using the NCBI BLAST server against nrdb.
\&
\&           It chooses the flavour of BLAST on the basis of the sequence.
\&
\&           This function uses Bio::Tools::Run::RemoteBlast, which itself
\&           use Bio::SearchIO \- as soon as you want to know more, check out
\&           these modules
\& Returns : Bio::Search::Result::GenericResult.pm
\&
\& Args    : Either a string of protein letters or nucleotides, or a
\&           Bio::Seq object
.Ve
.SS "write_blast"
.IX Subsection "write_blast"
.Vb 2
\& Title   : write_blast
\& Usage   : write_blast($filename,$blast_report);
\&
\& Function: Writes a BLAST result object (or more formally
\&           a SearchIO result object) out to a filename
\&           in BLAST\-like format
\&
\& Returns : none
\&
\& Args    : filename as a string
\&           Bio::SearchIO::Results object
.Ve
.SS "get_sequence"
.IX Subsection "get_sequence"
.Vb 2
\& Title   : get_sequence
\& Usage   : $seq_object = get_sequence(\*(Aqswiss\*(Aq,"ROA1_HUMAN");
\&
\& Function: If the computer has Internet access this method gets
\&           the sequence from Internet accessible databases. Currently
\&           this supports Swissprot (\*(Aqswiss\*(Aq), EMBL (\*(Aqembl\*(Aq), GenBank
\&           (\*(Aqgenbank\*(Aq), GenPept (\*(Aqgenpept\*(Aq), and RefSeq (\*(Aqrefseq\*(Aq).
\&
\&           Swissprot and EMBL are more robust than GenBank fetching.
\&
\&           If the user is trying to retrieve a RefSeq entry from
\&           GenBank/EMBL, the query is silently redirected.
\&
\& Returns : A Bio::Seq object
\&
\& Args    : database type \- one of swiss, embl, genbank, genpept, or
\&           refseq
.Ve
.SS "translate"
.IX Subsection "translate"
.Vb 2
\& Title   : translate
\& Usage   : $seqobj = translate($seq_or_string_scalar)
\&
\& Function: translates a DNA sequence object OR just a plain
\&           string of DNA to amino acids
\& Returns : A Bio::Seq object
\&
\& Args    : Either a sequence object or a string of
\&           just DNA sequence characters
.Ve
.SS "translate_as_string"
.IX Subsection "translate_as_string"
.Vb 2
\& Title   : translate_as_string
\& Usage   : $seqstring = translate_as_string($seq_or_string_scalar)
\&
\& Function: translates a DNA sequence object OR just a plain
\&           string of DNA to amino acids
\& Returns : A string of just amino acids
\&
\& Args    : Either a sequence object or a string of
\&           just DNA sequence characters
.Ve
.SS "reverse_complement"
.IX Subsection "reverse_complement"
.Vb 2
\& Title   : reverse_complement
\& Usage   : $seqobj = reverse_complement($seq_or_string_scalar)
\&
\& Function: reverse complements a string or sequence argument
\&           producing a Bio::Seq \- if you want a string, you
\&           can use reverse_complement_as_string
\& Returns : A Bio::Seq object
\&
\& Args    : Either a sequence object or a string of
\&           just DNA sequence characters
.Ve
.SS "revcom"
.IX Subsection "revcom"
.Vb 2
\& Title   : revcom
\& Usage   : $seqobj = revcom($seq_or_string_scalar)
\&
\& Function: reverse complements a string or sequence argument
\&           producing a Bio::Seq \- if you want a string, you
\&           can use reverse_complement_as_string
\&
\&           This is an alias for reverse_complement
\& Returns : A Bio::Seq object
\&
\& Args    : Either a sequence object or a string of
\&           just DNA sequence characters
.Ve
.SS "reverse_complement_as_string"
.IX Subsection "reverse_complement_as_string"
.Vb 2
\& Title   : reverse_complement_as_string
\& Usage   : $string = reverse_complement_as_string($seq_or_string_scalar)
\&
\& Function: reverse complements a string or sequence argument
\&           producing a string
\& Returns : A string of DNA letters
\&
\& Args    : Either a sequence object or a string of
\&           just DNA sequence characters
.Ve
.SS "revcom_as_string"
.IX Subsection "revcom_as_string"
.Vb 2
\& Title   : revcom_as_string
\& Usage   : $string = revcom_as_string($seq_or_string_scalar)
\&
\& Function: reverse complements a string or sequence argument
\&           producing a string
\& Returns : A string of DNA letters
\&
\& Args    : Either a sequence object or a string of
\&           just DNA sequence characters
.Ve
