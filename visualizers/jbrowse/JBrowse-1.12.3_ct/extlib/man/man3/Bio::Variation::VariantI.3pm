.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Variation::VariantI 3"
.TH Bio::Variation::VariantI 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Variation::VariantI \- Sequence Change SeqFeature abstract class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  #get Bio::Variant::VariantI somehow
\&  print $var\->restriction_changes, "\en";
\&  foreach $allele ($var\->each_Allele) {
\&      #work on Bio::Variation::Allele objects
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This superclass defines common methods to basic sequence changes.  The
instantiable classes Bio::Variation::DNAMutation,
Bio::Variation::RNAChange and Bio::Variation::AAChange use them.
See Bio::Variation::DNAMutation, Bio::Variation::RNAChange,
and Bio::Variation::AAChange for more information.
.PP
These classes store information, heavy computation to determine allele
sequences is done elsewhere.
.PP
The database cross-references are implemented as
Bio::Annotation::DBLink objects. The methods to access them are
defined in Bio::DBLinkContainerI. See Bio::Annotation::DBLink
and Bio::DBLinkContainerI for details.
.PP
Bio::Variation::VariantI redifines and extends
Bio::SeqFeature::Generic for sequence variations. This class
describes specific sequence change events. These events are always
from a specific reference sequence to something different. See
Bio::SeqFeature::Generic for more information.
.PP
\&\s-1IMPORTANT:\s0 The notion of reference sequence permeates all
Bio::Variation classes. This is especially important to remember when
dealing with Alleles. In a polymorphic site, there can be a large
number of alleles. One of then has to be selected to be the reference
allele (allele_ori). \s-1ALL\s0 the rest has to be passed to the Variant
using the method add_Allele, including the mutated allele in a
canonical mutation. The \s-1IO\s0 modules and generated attributes depend on
it. They ignore the allele linked to using allele_mut and circulate
each Allele returned by each_Allele into allele_mut and calculate
the changes between that and allele_ori.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to the 
Bioperl mailing lists  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Heikki Lehvaslaiho"
.IX Header "AUTHOR - Heikki Lehvaslaiho"
Email:  heikki-at-bioperl-dot-org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "id"
.IX Subsection "id"
.Vb 3
\& Title   : id
\& Usage   : $obj\->id
\& Function:
\&
\&           Read only method. Returns the id of the variation object.
\&           The id is the id of the first DBLink object attached to this object.
\&
\& Example :
\& Returns : scalar
\& Args    : none
.Ve
.SS "add_Allele"
.IX Subsection "add_Allele"
.Vb 3
\& Title   : add_Allele
\& Usage   : $self\->add_Allele($allele)
\& Function: 
\&
\&            Adds one Bio::Variation::Allele into the list of alleles.
\&            Note that the method forces the convention that nucleotide
\&            sequence is in lower case and amino acds are in upper
\&            case.
\&
\& Example : 
\& Returns : 1 when succeeds, 0 for failure.
\& Args    : Allele object
.Ve
.SS "each_Allele"
.IX Subsection "each_Allele"
.Vb 3
\& Title   : alleles
\& Usage   : $obj\->each_Allele();
\& Function: 
\&
\&             Returns a list of Bio::Variation::Allele objects
\&
\& Example : 
\& Returns : list of Alleles
\& Args    : none
.Ve
.SS "isMutation"
.IX Subsection "isMutation"
.Vb 3
\& Title   : isMutation
\& Usage   : print join(\*(Aq/\*(Aq, $obj\->each_Allele) if not $obj\->isMutation;
\& Function:
\&
\&           Returns or sets the boolean value indicating that the
\&           variant described is a canonical mutation with two alleles
\&           assinged to be the original (wild type) allele and mutated
\&           allele, respectively. If this value is not set, it is
\&           assumed that the Variant describes polymorphisms.
\&
\& Returns : a boolean
.Ve
.SS "allele_ori"
.IX Subsection "allele_ori"
.Vb 3
\& Title   : allele_ori
\& Usage   : $obj\->allele_ori();
\& Function: 
\&
\&            Links to and returns the Bio::Variation::Allele object.
\&            If value is not set, returns false. All other Alleles are
\&            compared to this.
\&
\&            Amino acid sequences are stored in upper case characters,
\&            others in lower case.
\&
\& Example : 
\& Returns : string
\& Args    : string
.Ve
.PP
See Bio::Variation::Allele for more.
.SS "allele_mut"
.IX Subsection "allele_mut"
.Vb 3
\& Title   : allele_mut
\& Usage   : $obj\->allele_mut();
\& Function: 
\&
\&             Links to and returns the Bio::Variation::Allele
\&             object.  Sets and returns the mutated allele sequence.
\&             If value is not set, returns false.
\&
\&             Amino acid sequences are stored in upper case characters,
\&             others in lower case.
\&
\& Example : 
\& Returns : string
\& Args    : string
.Ve
.PP
See Bio::Variation::Allele for more.
.SS "length"
.IX Subsection "length"
.Vb 3
\& Title   : length
\& Usage   : $obj\->length();
\& Function: 
\&
\&            Sets and returns the length of the affected original
\&            allele sequence.  If value is not set, returns false == 0.
\&
\&            Value 0 means that the variant position is before the
\&            start=end sequence position. (Value 1 would denote a point
\&            mutation). This follows the convension to report an
\&            insertion (2insT) in equivalent way to a corresponding
\&            deletion (2delT) (Think about indel polymorpism ATC <=> AC
\&            where the origianal state is not known ).
\&
\& Example : 
\& Returns : string
\& Args    : string
.Ve
.SS "upStreamSeq"
.IX Subsection "upStreamSeq"
.Vb 3
\& Title   : upStreamSeq
\& Usage   : $obj\->upStreamSeq();
\& Function: 
\&
\&            Sets and returns upstream flanking sequence string.  If
\&            value is not set, returns false. The sequence should be
\&            >=25 characters long, if possible.
\&
\& Example : 
\& Returns : string or false
\& Args    : string
.Ve
.SS "dnStreamSeq"
.IX Subsection "dnStreamSeq"
.Vb 3
\& Title   : dnStreamSeq
\& Usage   : $obj\->dnStreamSeq();
\& Function: 
\&
\&            Sets and returns dnstream flanking sequence string.  If
\&            value is not set, returns false. The sequence should be
\&            >=25 characters long, if possible.
\&
\& Example : 
\& Returns : string or false
\& Args    : string
.Ve
.SS "label"
.IX Subsection "label"
.Vb 3
\& Title   : label
\& Usage   : $obj\->label();
\& Function: 
\&
\&            Sets and returns mutation event label(s).  If value is not
\&            set, or no argument is given returns false.  Each
\&            instantiable class needs to implement this method. Valid
\&            values are listed in \*(AqMutation event controlled vocabulary\*(Aq in
\&            http://www.ebi.ac.uk/mutations/recommendations/mutevent.html.
\&
\& Example : 
\& Returns : string
\& Args    : string
.Ve
.SS "status"
.IX Subsection "status"
.Vb 3
\& Title   : status
\& Usage   : $obj\->status()
\& Function: 
\&
\&           Returns the status of the sequence change object.
\&           Valid values are: \*(Aqsuspected\*(Aq and \*(Aqproven\*(Aq
\&
\& Example : $obj\->status(\*(Aqproven\*(Aq);
\& Returns : scalar
\& Args    : valid string (optional, for setting)
.Ve
.SS "proof"
.IX Subsection "proof"
.Vb 3
\& Title   : proof
\& Usage   : $obj\->proof()
\& Function: 
\&
\&           Returns the proof of the sequence change object.
\&           Valid values are: \*(Aqcomputed\*(Aq and \*(Aqexperimental\*(Aq.
\&
\& Example : $obj\->proof(\*(Aqcomputed\*(Aq);
\& Returns : scalar
\& Args    : valid string (optional, for setting)
.Ve
.SS "region"
.IX Subsection "region"
.Vb 3
\& Title   : region
\& Usage   : $obj\->region();
\& Function: 
\&
\&            Sets and returns the name of the sequence region type or
\&            protein domain at this location.  If value is not set,
\&            returns false.
\&
\& Example : 
\& Returns : string
\& Args    : string
.Ve
.SS "region_value"
.IX Subsection "region_value"
.Vb 3
\& Title   : region_value
\& Usage   : $obj\->region_value();
\& Function: 
\&
\&            Sets and returns the name of the sequence region_value or
\&            protein domain at this location.  If value is not set,
\&            returns false.
\&
\& Example : 
\& Returns : string
\& Args    : string
.Ve
.SS "region_dist"
.IX Subsection "region_dist"
.Vb 3
\& Title   : region_dist
\& Usage   : $obj\->region_dist();
\& Function: 
\&
\&            Sets and returns the distance tot the closest region
\&            (i.e. intro/exon or domain) boundary. If distance is not
\&            set, returns false.
\&
\& Example : 
\& Returns : integer
\& Args    : integer
.Ve
.SS "numbering"
.IX Subsection "numbering"
.Vb 3
\& Title   : numbering
\& Usage   : $obj\->numbering()
\& Function: 
\&
\&           Returns the numbering chema used locating sequnce features.
\&           Valid values are: \*(Aqentry\*(Aq and \*(Aqcoding\*(Aq
\&
\& Example : $obj\->numbering(\*(Aqcoding\*(Aq);
\& Returns : scalar
\& Args    : valid string (optional, for setting)
.Ve
.SS "mut_number"
.IX Subsection "mut_number"
.Vb 4
\& Title   : mut_number
\& Usage   : $num = $obj\->mut_number;
\&         : $num = $obj\->mut_number($number);
\& Function: 
\&
\&           Returns or sets the number identifying the order in which the
\&           mutation has been issued. Numbers shouldstart from 1.
\&           If the number has never been set, the method will return \*(Aq\*(Aq
\&
\&           If you want the output from IO modules look nice and, for
\&           multivariant/allele variations, make sense you better set
\&           this attribute.
\&
\& Returns : an integer
.Ve
.SS "SeqDiff"
.IX Subsection "SeqDiff"
.Vb 4
\& Title   : SeqDiff
\& Usage   : $mutobj = $obj\->SeqDiff;
\&         : $mutobj = $obj\->SeqDiff($objref);
\& Function: 
\&
\&           Returns or sets the link\-reference to the umbrella
\&           Bio::Variation::SeqDiff object.  If there is no link,
\&           it will return undef
\&
\&           Note: Adding a variant into a SeqDiff object will
\&           automatically set this value.
\&
\& Returns : an obj_ref or undef
.Ve
.PP
See Bio::Variation::SeqDiff for more information.
.SS "add_DBLink"
.IX Subsection "add_DBLink"
.Vb 6
\& Title   : add_DBLink
\& Usage   : $self\->add_DBLink($ref)
\& Function: adds a link object
\& Example :
\& Returns : 
\& Args    :
.Ve
.SS "each_DBLink"
.IX Subsection "each_DBLink"
.Vb 6
\& Title   : each_DBLink
\& Usage   : foreach $ref ( $self\->each_DBlink() )
\& Function: gets an array of DBlink of objects
\& Example :
\& Returns : 
\& Args    :
.Ve
.SS "restriction_changes"
.IX Subsection "restriction_changes"
.Vb 3
\& Title   : restriction_changes
\& Usage   : $obj\->restriction_changes();
\& Function: 
\&
\&            Returns a string containing a list of restriction
\&            enzyme changes of form +EcoRI, separated by
\&            commas. Strings need to be valid restriction enzyme names
\&            as stored in REBASE. allele_ori and allele_mut need to be assigned.
\&
\& Example : 
\& Returns : string
\& Args    : string
.Ve
