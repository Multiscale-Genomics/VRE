.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::Query::HIVQuery 3"
.TH Bio::DB::Query::HIVQuery 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::Query::HIVQuery \- Query interface to the Los Alamos HIV Sequence Database
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    $q = new Bio::DB::Query::HIVQuery(" C[subtype] ZA[country] CXCR4[coreceptor] ");
\&    $q = new Bio::DB::Query::HIVQuery(
\&         \-query=>{\*(Aqsubtype\*(Aq=>\*(AqC\*(Aq, 
\&                  \*(Aqcountry\*(Aq=>\*(AqZA\*(Aq, 
\&                  \*(Aqcoreceptor\*(Aq=>\*(AqCXCR4\*(Aq});
\&
\&    $ac = $q\->get_annotations_by_id(($q\->ids)[0]);
\&    $ac\->get_value(\*(AqGeo\*(Aq, \*(Aqcountry\*(Aq)                    # returns \*(AqSOUTH AFRICA\*(Aq
\&
\&    $db = new Bio::DB::HIV();
\&    $seqio = $db\->get_Stream_by_query($q);              # returns annotated Bio::Seqs 
\&
\&    # get subtype C sequences from South Africa and Brazil, 
\&    # with associated info on patient health, coreceptor use, and 
\&    # infection period:
\&
\&    $q = new Bio::DB::Query::HIVQuery(
\&         \-query => {
\&                    \*(Aqquery\*(Aq => {\*(Aqsubtype\*(Aq=>\*(AqC\*(Aq,
\&                    \*(Aqcountry\*(Aq=>[\*(AqZA\*(Aq, \*(AqBR\*(Aq]},
\&                    \*(Aqannot\*(Aq => [\*(Aqpatient_health\*(Aq, 
\&                                \*(Aqcoreceptor\*(Aq, 
\&                                \*(Aqdays_post_infection\*(Aq]
\&                    });
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::DB::Query::HIVQuery provides a query-like interface to the
cgi-based Los Alamos National Laboratory (\s-1LANL\s0) \s-1HIV\s0 Sequence
Database. It uses Bioperl facilities to capture both sequences and
annotations in batch in an automated and computable way. Use with
Bio::DB::HIV to create \f(CW\*(C`Bio::Seq\*(C'\fR objects and annotated \f(CW\*(C`Bio::SeqIO\*(C'\fR
streams.
.SS "Query format"
.IX Subsection "Query format"
The interface implements a simple query language emulation that understands \s-1AND,
OR,\s0 and parenthetical nesting. The basic query unit is
.PP
.Vb 1
\& (match1 match2 ...)[fieldname]
.Ve
.PP
Sequences are returned for which \f(CW\*(C`fieldname\*(C'\fR equals \f(CW\*(C`match1 OR match2 OR ...\*(C'\fR.
These units can be combined with \s-1AND, OR\s0 and parentheses. For example:
.PP
.Vb 1
\& (B, C)[subtype] AND (2000, 2001, 2002, 2003)[year] AND ((CN)[country] OR (ZA)[country])
.Ve
.PP
which can be shortened to
.PP
.Vb 1
\& (B C)[subtype] (2000 2001 2002 2003)[year] (CN ZA)[country]
.Ve
.PP
The user can specify annotation fields, that do not restrict the query, but
arrange for the return of the associated field data for each sequence returned.
Specify annotation fields between curly braces, as in:
.PP
.Vb 1
\& (B C)[subtype] 2000[year] {country cd4_count cd8_count}
.Ve
.PP
Annotations can be accessed off the query using methods described in \s-1APPENDIX.\s0
.SS "Hash specifications for query construction"
.IX Subsection "Hash specifications for query construction"
Single query specifications can be made as hash references provided to the
\&\f(CW\*(C`\-query\*(C'\fR argument of the constructor. There are two forms:
.PP
.Vb 1
\& \-query => { \*(Aqcountry\*(Aq=>\*(AqBR\*(Aq, \*(Aqphenotype\*(Aq=>\*(AqNSI\*(Aq, \*(Aqcd4_count\*(Aq=>\*(AqAny\*(Aq }
.Ve
.PP
equivalent to
.PP
.Vb 1
\& \-query => [ \*(Aqcountry\*(Aq=>\*(AqBR\*(Aq, \*(Aqphenotype\*(Aq=>\*(AqNSI\*(Aq, \*(Aqcd4_count\*(Aq=>\*(AqAny\*(Aq ]
.Ve
.PP
or
.PP
.Vb 2
\& \-query => { \*(Aqquery\*(Aq => {\*(Aqcountry\*(Aq=>\*(AqBR\*(Aq, \*(Aqphenotype\*(Aq=>\*(AqNSI\*(Aq},
\&             \*(Aqannot\*(Aq => [\*(Aqcd4_count\*(Aq] }
.Ve
.PP
In both cases, the \s-1CD4\s0 count is included in the annotations returned, but does
not restrict the rest of the query.
.PP
To '\s-1OR\s0' multiple values of a field, use an anonymous array ref:
.PP
.Vb 1
\& \-query => { \*(Aqcountry\*(Aq=>[\*(AqZA\*(Aq,\*(AqBR\*(Aq,\*(AqNL\*(Aq], \*(Aqsubtype\*(Aq=>[\*(AqA\*(Aq, \*(AqC\*(Aq, \*(AqD\*(Aq] }
.Ve
.SS "Valid query field names"
.IX Subsection "Valid query field names"
An attempt was made to make the query field names natural and easy to
remember. Aliases are specified in an \s-1XML\s0 file (\f(CW\*(C`lanl\-schema.xml\*(C'\fR) that is part
of the distribution. Custom field aliases can be set up by modifying this file.
.PP
An \s-1HTML\s0 cheatsheet with valid field names, aliases, and match data can be
generated from the \s-1XML\s0 by using \f(CW\*(C`hiv_object\->help(\*(Aqhelp.html\*(Aq)\*(C'\fR. A query
can also be validated locally before it is unleashed on the server; see below.
.SS "Annotations"
.IX Subsection "Annotations"
\&\s-1LANL DB\s0 annotations have been organized into a number of natural
groupings, tagged \f(CW\*(C`Geo\*(C'\fR, \f(CW\*(C`Patient\*(C'\fR, \f(CW\*(C`Virus\*(C'\fR, and \f(CW\*(C`StdMap\*(C'\fR.  After a
successful query, each id is associated with a tree of
Bio::Annotation::SimpleValue objects. These can be accessed with
methods \f(CW\*(C`get_value\*(C'\fR and \f(CW\*(C`put_value\*(C'\fR described in \s-1APPENDIX.\s0
.SS "Delayed/partial query runs"
.IX Subsection "Delayed/partial query runs"
Accessing the \s-1LANL DB\s0 involves multiple \s-1HTTP\s0 requests. The query can
be instructed to proceed through all (the default) or only some of
them, using the named parameter \f(CW\*(C`RUN_OPTION\*(C'\fR.
.PP
To validate a query locally, use
.PP
.Vb 1
\& $q = new Bio::DB::Query::HIVQuery( \-query => {...}, \-RUN_OPTION=>0 )
.Ve
.PP
which will throw an exception if a field name or option is invalid.
.PP
To get a query count only, you can save a server hit by using
.PP
.Vb 1
\& $q = new Bio::DB::Query::HIVQuery( \-query => {...}, \-RUN_OPTION=>1 )
.Ve
.PP
and asking for \f(CW\*(C`$q\->count\*(C'\fR. To finish the query, do
.PP
.Vb 1
\& $q\->_do_query(2)
.Ve
.PP
which picks up where you left off.
.PP
\&\f(CW\*(C`\-RUN_OPTION=>2\*(C'\fR, the default, runs the full query, returning ids and
annotations.
.SS "Query re-use"
.IX Subsection "Query re-use"
You can clear the query results, retaining the same \s-1LANL\s0 session and query spec,
by doing \f(CW\*(C`$q\->_reset\*(C'\fR. Change the query, and rerun with
\&\f(CW\*(C`$q\->_do_query($YOUR_RUN_OPTION)\*(C'\fR.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via
the web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Mark A. Jensen"
.IX Header "AUTHOR - Mark A. Jensen"
Email maj@fortinbras.us
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Mark A. Jensen
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SH "Constructor"
.IX Header "Constructor"
.SS "new"
.IX Subsection "new"
.Vb 7
\& Title   : new
\& Usage   : my $hiv_query = new Bio::DB::Query::HIVQuery();
\& Function: Builds a new Bio::DB::Query::HIVQuery object,
\&           running a sequence query against the Los Alamos
\&           HIV sequence database
\& Returns : an instance of Bio::DB::Query::HIVQuery
\& Args    :
.Ve
.SH "QueryI compliance"
.IX Header "QueryI compliance"
.SS "count"
.IX Subsection "count"
.Vb 8
\& Title   : count
\& Usage   : $hiv_query\->count($newval)
\& Function: return number of sequences found
\& Example : 
\& Returns : value of count (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
\& Note    : count warns if it is accessed for reading before query
\&           has been executed to at least level 1
.Ve
.SS "ids"
.IX Subsection "ids"
.Vb 6
\& Title   : ids
\& Usage   : $hiv_query\->ids($newval)
\& Function: LANL ids of returned sequences 
\& Example : 
\& Returns : value of ids (an arrayref of sequence accessions/ids)
\& Args    : on set, new value (an arrayref or undef, optional)
.Ve
.SS "query"
.IX Subsection "query"
.Vb 6
\& Title   : query
\& Usage   : $hiv_query\->query
\& Function: Get/set the submitted query hash or string
\& Example :
\& Returns : hashref or string
\& Args    : query in hash or string form (see DESCRIPTION)
.Ve
.SH "Bio::DB::Query::HIVQuery specific methods"
.IX Header "Bio::DB::Query::HIVQuery specific methods"
.SS "help"
.IX Subsection "help"
.Vb 7
\& Title   : help
\& Usage   : $hiv_query\->help("help.html")
\& Function: get html\-formatted listing of valid fields/aliases/options
\&           based on current schema xml
\& Example : perl \-MBio::DB::Query::HIVQuery \-e "new Bio::DB::Query::HIVQuery()\->help" | lynx \-stdin
\& Returns : HTML
\& Args    : optional filename; otherwise prints to stdout
.Ve
.SH "Annotation manipulation methods"
.IX Header "Annotation manipulation methods"
.SS "get_annotations_by_ids"
.IX Subsection "get_annotations_by_ids"
.Vb 6
\& Title   : get_annotations_by_ids (or ..._by_id)
\& Usage   : $ac = $hiv_query\->get_annotations_by_ids(@ids)
\& Function: Get the Bio::Annotation::Collection for these sequence ids
\& Example :
\& Returns : A Bio::Annotation::Collection object
\& Args    : an array of sequence ids
.Ve
.SS "add_annotations_for_id"
.IX Subsection "add_annotations_for_id"
.Vb 9
\& Title   : add_annotations_for_id
\& Usage   : $hiv_query\->add_annotations_for_id( $id ) to create a new 
\&            empty collection for $id
\&           $hiv_query\->add_annotations_for_id( $id, $ac ) to associate 
\&           $ac with $id
\& Function: Associate a Bio::Annotation::Collection with this sequence id
\& Example :
\& Returns : a Bio::Annotation::Collection object
\& Args    : sequence id [, Bio::Annotation::Collection object]
.Ve
.SS "remove_annotations_for_ids"
.IX Subsection "remove_annotations_for_ids"
.Vb 6
\& Title   : remove_annotations_for_ids (or ..._for_id)
\& Usage   : $hiv_query\->remove_annotations_for_ids( @ids)
\& Function: Remove annotation collection for this sequence id
\& Example :
\& Returns : An array of the previous annotation collections for these ids
\& Args    : an array of sequence ids
.Ve
.SS "remove_annotations"
.IX Subsection "remove_annotations"
.Vb 6
\& Title   : remove_annotations
\& Usage   : $hiv_query\->remove_annotations()
\& Function: Remove all annotation collections for this object
\& Example :
\& Returns : The previous annotation collection hash for this object
\& Args    : none
.Ve
.SS "get_value"
.IX Subsection "get_value"
.Vb 9
\& Title   : get_value
\& Usage   : $ac\->get_value($tagname) \-or\-
\&           $ac\->get_value( $tag_level1, $tag_level2,... )
\& Function: access the annotation value associated with the given tags
\& Example :
\& Returns : a scalar
\& Args    : an array of tagnames that descend into the annotation tree
\& Note    : this is a L<Bio::AnnotationCollectionI> method added in 
\&           L<Bio::DB::HIV::HIVQueryHelper>
.Ve
.SS "put_value"
.IX Subsection "put_value"
.Vb 10
\& Title   : put_value
\& Usage   : $ac\->put_value($tagname, $value) \-or\-
\&           $ac\->put_value([$tag_level1, $tag_level2, ...], $value) \-or\-
\&           $ac\->put_value( [$tag_level1, $tag_level2, ...] )
\& Function: create a node in an annotation tree, and assign a scalar value to it
\&           if a value is specified
\& Example :
\& Returns : scalar or a Bio::AnnotationCollection object
\& Args    : $tagname, $value scalars (can be specified as \-KEYS=>$tagname,
\&           \-VALUE=>$value) \-or\- 
\&           \e@tagnames, $value (or as \-KEYS=>\e@tagnames, \-VALUE=>$value )
\& Notes   : This is a L<Bio::AnnotationCollectionI> method added in 
\&           L<Bio::DB::HIV::HIVQueryHelper>.
\&           If intervening nodes do not exist, put_value creates them, replacing 
\&           existing nodes. So if $ac\->put_value(\*(Aqx\*(Aq, 10) was done, then later,
\&           $ac\->put_value([\*(Aqx\*(Aq, \*(Aqy\*(Aq], 20), the original value of \*(Aqx\*(Aq is trashed,
\&           and $ac\->get_value(\*(Aqx\*(Aq) will now return the annotation collection 
\&           with tagname \*(Aqy\*(Aq.
.Ve
.SS "get_keys"
.IX Subsection "get_keys"
.Vb 7
\& Title   : get_keys
\& Usage   : $ac\->get_keys($tagname_level_1, $tagname_level_2,...)
\& Function: Get an array of tagnames underneath the named tag nodes
\& Example : # prints the values of the members of Category 1...
\&           print map { $ac\->get_value($_) } $ac\->get_keys(\*(AqCategory 1\*(Aq) ;
\& Returns : array of tagnames or empty list if the arguments represent a leaf
\& Args    : [array of] tagname[s]
.Ve
.SH "GenBank accession manipulation methods"
.IX Header "GenBank accession manipulation methods"
.SS "get_accessions"
.IX Subsection "get_accessions"
.Vb 8
\& Title   : get_accessions
\& Usage   : $hiv_query\->get_accessions()
\& Function: Return an array of GenBank accessions associated with these 
\&           sequences (available only after a query is subjected to a 
\&           full run (i.e., when $RUN_OPTION == 2)
\& Example :
\& Returns : array of gb accession numbers, or () if none found for this query
\& Args    : none
.Ve
.SS "get_accessions_by_ids"
.IX Subsection "get_accessions_by_ids"
.Vb 8
\& Title   : get_accessions_by_ids (or ..._by_id)
\& Usage   : $hiv_query\->get_accessions_by_ids(@ids)
\& Function: Return an array of GenBank accessions associated with these 
\&           LANL ids (available only after a query is subjected to a 
\&           full run (i.e., when $RUN_OPTION == 2)
\& Example :
\& Returns : array of gb accession numbers, or () if none found for this query
\& Args    : none
.Ve
.SH "Query control methods"
.IX Header "Query control methods"
.SS "_do_query"
.IX Subsection "_do_query"
.Vb 12
\& Title   : _do_query
\& Usage   : $hiv_query\->_do_query or $hiv_query\->_do_query($run_level)
\& Function: Execute the query according to argument or $RUN_OPTION
\&           and set _RUN_LEVEL
\&           extent of query reflects the value of argument
\&            0 : validate only (no HTTP action)
\&            1 : return sequence count only
\&            2 : return sequence ids (full query, returns with annotations)
\&           noop if current _RUN_LEVEL of query is >= argument or $RUN_OPTION,
\& Example :
\& Returns : actual _RUN_LEVEL (0, 1, or 2) achieved
\& Args    : desired run level (optional, global $RUN_OPTION is default)
.Ve
.SS "_reset"
.IX Subsection "_reset"
.Vb 7
\& Title   : _reset
\& Usage   : $hiv_query\->_reset
\& Function: Resets query storage, count, and ids, while retaining session id, 
\&           original query string, and db schema
\& Example : 
\& Returns : void
\& Args    : none
.Ve
.SS "_session_id"
.IX Subsection "_session_id"
.Vb 6
\& Title   : _session_id
\& Usage   : $hiv_query\->_session_id($newval)
\& Function: Get/set HIV db session id (initialized in _do_lanl_request)
\& Example : 
\& Returns : value of _session_id (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "_run_level"
.IX Subsection "_run_level"
.Vb 6
\& Title   : _run_level
\& Usage   : $obj\->_run_level($newval)
\& Function: returns the level at which the query has so far been run
\& Example : 
\& Returns : value of _run_level (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "_run_option"
.IX Subsection "_run_option"
.Vb 6
\& Title   : _run_option
\& Usage   : $hiv_query\->_run_option($newval)
\& Function: Get/set HIV db query run option (see _do_query for values)
\& Example : 
\& Returns : value of _run_option (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "_ua_hash"
.IX Subsection "_ua_hash"
.Vb 6
\& Title   : _ua_hash
\& Usage   : $obj\->_ua_hash($newval)
\& Function: 
\& Example : 
\& Returns : value of _ua_hash (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SH "Internals"
.IX Header "Internals"
.SS "add_id"
.IX Subsection "add_id"
.Vb 6
\& Title   : add_id
\& Usage   : $hiv_query\->add_id($id)
\& Function: Add new id to ids
\& Example : 
\& Returns : the new id
\& Args    : a sequence id
.Ve
.SS "map_db"
.IX Subsection "map_db"
.Vb 6
\& Title   : map_db
\& Usage   : $obj\->map_db($newval)
\& Function: 
\& Example : 
\& Returns : value of map_db (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "make_search_if"
.IX Subsection "make_search_if"
.Vb 6
\& Title   : make_search_if
\& Usage   : $obj\->make_search_if($newval)
\& Function: 
\& Example : 
\& Returns : value of make_search_if (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "search_"
.IX Subsection "search_"
.Vb 6
\& Title   : search_
\& Usage   : $obj\->search_($newval)
\& Function: 
\& Example : 
\& Returns : value of search_ (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "_map_db_uri"
.IX Subsection "_map_db_uri"
.Vb 6
\& Title   : _map_db_uri
\& Usage   :
\& Function: return the full map_db uri ("Database Map")
\& Example :
\& Returns : scalar string
\& Args    : none
.Ve
.SS "_make_search_if_uri"
.IX Subsection "_make_search_if_uri"
.Vb 6
\& Title   : _make_search_if_uri
\& Usage   :
\& Function: return the full make_search_if uri ("Make Search Interface")
\& Example :
\& Returns : scalar string
\& Args    : none
.Ve
.SS "_search_uri"
.IX Subsection "_search_uri"
.Vb 6
\& Title   : _search_uri
\& Usage   :
\& Function: return the full search cgi uri ("Search Database")
\& Example :
\& Returns : scalar string
\& Args    : none
.Ve
.SS "_schema_file"
.IX Subsection "_schema_file"
.Vb 6
\& Title   : _schema_file
\& Usage   : $hiv_query\->_schema_file($newval)
\& Function: 
\& Example : 
\& Returns : value of _schema_file (an XML string or filename)
\& Args    : on set, new value (an XML string or filename, or undef, optional)
.Ve
.SS "_schema"
.IX Subsection "_schema"
.Vb 7
\& Title   : _schema
\& Usage   : $hiv_query\->_schema($newVal)
\& Function: 
\& Example : 
\& Returns : value of _schema (an HIVSchema object in package 
\&           L<Bio::DB::HIV::HIVQueryHelper>)
\& Args    : none (field set directly in new())
.Ve
.SS "_lanl_query"
.IX Subsection "_lanl_query"
.Vb 6
\& Title   : _lanl_query
\& Usage   : $hiv_query\->_lanl_query(\e@query_parms)
\& Function: pushes \e@query_parms onto @{$self\->{\*(Aq_lanl_query\*(Aq}
\& Example : 
\& Returns : value of _lanl_query (an arrayref)
\& Args    : on set, new value (an arrayref or undef, optional)
.Ve
.SS "_lanl_response"
.IX Subsection "_lanl_response"
.Vb 6
\& Title   : _lanl_response
\& Usage   : $hiv_query\->_lanl_response($response)
\& Function: pushes $response onto @{$hiv_query\->{\*(Aq_lanl_response\*(Aq}}
\& Example : 
\& Returns : value of _lanl_response (an arrayref of HTTP::Response objects)
\& Args    : on set, new value (an HTTP::Response object or undef, optional)
.Ve
.SS "_create_lanl_query"
.IX Subsection "_create_lanl_query"
.Vb 6
\& Title   : _create_lanl_query
\& Usage   : $hiv_query\->_create_lanl_query()
\& Function: validate query hash or string, prepare for _do_lanl_request
\& Example : 
\& Returns : 1 if successful; throws exception on invalid query
\& Args    :
.Ve
.SS "_do_lanl_request"
.IX Subsection "_do_lanl_request"
.Vb 6
\& Title   : _do_lanl_request
\& Usage   : $hiv_query\->_do_lanl_request()
\& Function: Perform search request on _create_lanl_query\-validated query
\& Example : 
\& Returns : 1 if successful
\& Args    :
.Ve
.SS "_parse_lanl_response"
.IX Subsection "_parse_lanl_response"
.Vb 7
\& Title   : _parse_lanl_response
\& Usage   : $hiv_query\->_parse_lanl_response()
\& Function: Parse the tab\-separated\-value response obtained by _do_lanl_request
\&           for sequence ids, accessions, and annotations
\& Example : 
\& Returns : 1 if successful
\& Args    :
.Ve
.SS "_parse_query_string"
.IX Subsection "_parse_query_string"
.Vb 7
\& Title   : _parse_query_string
\& Usage   : $hiv_query\->_parse_query_string($str)
\& Function: Parses a query string using query language emulator QRY
\&         : in L<Bio::DB::Query::HIVQueryHelper>
\& Example : 
\& Returns : arrayref of hash structures suitable for passing to _create_lanl_query
\& Args    : a string scalar
.Ve
.SH "Dude, sorry\-"
.IX Header "Dude, sorry-"
.SS "_sorry"
.IX Subsection "_sorry"
.Vb 6
\& Title   : _sorry
\& Usage   : $hiv_query\->_sorry("\-president=>Powell")
\& Function: Throws an exception for unsupported option or parameter
\& Example :
\& Returns : 
\& Args    : scalar string
.Ve
