.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::GFF::Aggregator 3"
.TH Bio::DB::GFF::Aggregator 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::GFF::Aggregator \-\- Aggregate GFF groups into composite features
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Bio::DB::GFF;
\&
\& my $agg1 = Bio::DB::GFF::Aggregator\->new(\-method       => \*(Aqcistron\*(Aq,
\&                                          \-main_method  => \*(Aqlocus\*(Aq,
\&                                          \-sub_parts    => [\*(Aqallele\*(Aq,\*(Aqvariant\*(Aq]
\&                                         );
\&
\& my $agg2 = Bio::DB::GFF::Aggregator\->new(\-method       => \*(Aqsplice_group\*(Aq,
\&                                          \-sub_parts    => \*(Aqtranscript\*(Aq);
\&
\& my $db      = Bio::DB::GFF\->new( \-adaptor    => \*(Aqdbi:mysql\*(Aq,
\&                                  \-aggregator => [$agg1,$agg2],
\&                                  \-dsn        => \*(Aqdbi:mysql:elegans42\*(Aq,
\&                                 );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::DB::GFF::Aggregator is used to aggregate \s-1GFF\s0 groups into
composite features.  Each composite feature has a \*(L"main part\*(R", the
top-level feature, and a series of zero or more subparts, retrieved
with the \fIsub_SeqFeature()\fR method.  The aggregator class is designed to
be subclassable, allowing a variety of \s-1GFF\s0 feature types to be
supported.
.PP
The base Bio::DB::GFF::Aggregator class is generic, and can be used to
create specific instances to be passed to the \-aggregator argument of
Bio::DB::GFF\->\fInew()\fR call.  The various subclasses of
Bio::DB::GFF::Aggregator are tuned for specific common feature types
such as clones, gapped alignments and transcripts.
.PP
Instances of Bio::DB::GFF::Aggregator have three attributes:
.IP "\(bu" 3
method
.Sp
This is the \s-1GFF\s0 method field of the composite feature as a whole.  For
example, \*(L"transcript\*(R" may be used for a composite feature created by
aggregating individual intron, exon and \s-1UTR\s0 features.
.IP "\(bu" 3
main method
.Sp
Sometimes \s-1GFF\s0 groups are organized hierarchically, with one feature
logically containing another.  For example, in the C. elegans schema,
methods of type \*(L"Sequence:curated\*(R" correspond to regions covered by
curated genes.  There can be zero or one main methods.
.IP "\(bu" 3
subparts
.Sp
This is a list of one or more methods that correspond to the component
features of the aggregates.  For example, in the C. elegans database,
the subparts of transcript are \*(L"intron\*(R", \*(L"exon\*(R" and \*(L"\s-1CDS\*(R".\s0
.PP
Aggregators have two main methods that can be overridden in
subclasses:
.IP "\(bu" 4
\&\fIdisaggregate()\fR
.Sp
This method is called by the Adaptor object prior to fetching a list
of features.  The method is passed an associative array containing the
[method,source] pairs that the user has requested, and it returns a
list of raw features that it would like the adaptor to fetch.
.IP "\(bu" 4
\&\fIaggregate()\fR
.Sp
This method is called by the Adaptor object after it has fetched 
features.  The method is passed a list of raw features and is expected 
to add its composite features to the list.
.PP
The \fIdisaggregate()\fR and \fIaggregate()\fR methods provided by the base
Aggregator class should be sufficient for many applications.  In this
case, it suffices for subclasses to override the following methods:
.IP "\(bu" 4
\&\fImethod()\fR
.Sp
Return the default method for the composite feature as a whole.
.IP "\(bu" 4
\&\fImain_name()\fR
.Sp
Return the default main method name.
.IP "\(bu" 4
\&\fIpart_names()\fR
.Sp
Return a list of subpart method names.
.PP
Provided that \fImethod()\fR and \fIpart_names()\fR are overridden (and optionally
\&\fImain_name()\fR as well), then the bare name of the aggregator subclass
can be passed to the \-aggregator of Bio::DB::GFF\->\fInew()\fR.  For example,
this is a small subclass that will aggregate features of type \*(L"allele\*(R"
and \*(L"polymorphism\*(R" into an aggregate named \*(L"mutant\*(R":
.PP
.Vb 1
\&  package Bio::DB::GFF::Aggregator::mutant;
\&
\&  use strict;
\&  use Bio::DB::GFF::Aggregator;
\&
\&  use base qw(Bio::DB::GFF::Aggregator);
\&
\&  sub method { \*(Aqmutant\*(Aq }
\&
\&  sub part_names {
\&    return qw(allele polymorphism);
\&  }
\&
\&  1;
.Ve
.PP
Once installed, this aggregator can be passed to Bio::DB::GFF\->\fInew()\fR
by name like so:
.PP
.Vb 4
\& my $db      = Bio::DB::GFF\->new( \-adaptor    => \*(Aqdbi:mysql\*(Aq,
\&                                  \-aggregator => \*(Aqmutant\*(Aq,
\&                                  \-dsn        => \*(Aqdbi:mysql:elegans42\*(Aq,
\&                                 );
.Ve
.SH "API"
.IX Header "API"
The remainder of this document describes the public and private
methods implemented by this module.
.SS "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : $a = Bio::DB::GFF::Aggregator\->new(@args)
\& Function: create a new aggregator
\& Returns : a Bio::DB::GFF::Aggregator object
\& Args    : see below
\& Status  : Public
.Ve
.PP
This is the constructor for Bio::DB::GFF::Aggregator.  Named arguments 
are as follows:
.PP
.Vb 1
\&  \-method           the method for the composite feature
\&
\&  \-main_method      the top\-level raw feature, if any
\&
\&  \-sub_parts        the list of raw features that will form the subparts
\&                    of the composite feature (array reference or scalar)
.Ve
.SS "disaggregate"
.IX Subsection "disaggregate"
.Vb 6
\& Title   : disaggregate
\& Usage   : $a\->disaggregate($types,$factory)
\& Function: disaggregate type list into components
\& Returns : a true value if this aggregator should be called to reaggregate
\& Args    : see below
\& Status  : Public
.Ve
.PP
This method is called to disaggregate a list of types into the set of
low-level features to be retrieved from the \s-1GFF\s0 database.  The list of
types is passed as an array reference containing a series of
[method,source] pairs.  This method synthesizes a new set of
[method,source] pairs, and appends them to the list of requested
types, changing the list in situ.
.PP
Arguments:
.PP
.Vb 1
\&  $types           reference to an array of [method,source] pairs
\&
\&  $factory         reference to the Adaptor object that is calling
\&                   this method
.Ve
.PP
Note that the \s-1API\s0 allows \fIdisaggregate()\fR to remove types from the type
list.  This feature is probably not desirable and may be deprecated in 
the future.
.SS "aggregate"
.IX Subsection "aggregate"
.Vb 6
\& Title   : aggregate
\& Usage   : $features = $a\->aggregate($features,$factory)
\& Function: aggregate a feature list into composite features
\& Returns : an array reference containing modified features
\& Args    : see below
\& Status  : Public
.Ve
.PP
This method is called to aggregate a list of raw \s-1GFF\s0 features into the
set of composite features.  The method is called an array reference to
a set of Bio::DB::GFF::Feature objects.  It runs through the list,
creating new composite features when appropriate.  The method result
is an array reference containing the composite features.
.PP
Arguments:
.PP
.Vb 1
\&  $features        reference to an array of Bio::DB::GFF::Feature objects
\&
\&  $factory         reference to the Adaptor object that is calling
\&                   this method
.Ve
.PP
\&\s-1NOTE:\s0 The reason that the function result contains the raw features as
well as the aggregated ones is to allow queries like this one:
.PP
.Vb 1
\&  @features =  $segment\->features(\*(Aqexon\*(Aq,\*(Aqtranscript:curated\*(Aq);
.Ve
.PP
Assuming that \*(L"transcript\*(R" is the name of an aggregated feature and
that \*(L"exon\*(R" is one of its components, we do not want the transcript
aggregator to remove features of type \*(L"exon\*(R" because the user asked
for them explicitly.
.SS "method"
.IX Subsection "method"
.Vb 6
\& Title   : method
\& Usage   : $string = $a\->method
\& Function: get the method type for the composite feature
\& Returns : a string
\& Args    : none
\& Status  : Protected
.Ve
.PP
This method is called to get the method to be assigned to the
composite feature once it is aggregated.  It is called if the user did
not explicitly supply a \-method argument when the aggregator was
created.
.PP
This is the method that should be overridden in aggregator subclasses.
.SS "main_name"
.IX Subsection "main_name"
.Vb 6
\& Title   : main_name
\& Usage   : $string = $a\->main_name
\& Function: get the method type for the "main" component of the feature
\& Returns : a string
\& Args    : none
\& Status  : Protected
.Ve
.PP
This method is called to get the method of the \*(L"main component\*(R" of the
composite feature.  It is called if the user did not explicitly supply
a \-main\-method argument when the aggregator was created.
.PP
This is the method that should be overridden in aggregator subclasses.
.SS "part_names"
.IX Subsection "part_names"
.Vb 6
\& Title   : part_names
\& Usage   : @methods = $a\->part_names
\& Function: get the methods for the non\-main various components of the feature
\& Returns : a list of strings
\& Args    : none
\& Status  : Protected
.Ve
.PP
This method is called to get the list of methods of the \*(L"main component\*(R" of the
composite feature.  It is called if the user did not explicitly supply
a \-main\-method argument when the aggregator was created.
.PP
This is the method that should be overridden in aggregator subclasses.
.SS "require_whole_object"
.IX Subsection "require_whole_object"
.Vb 6
\& Title   : require_whole_object
\& Usage   : $bool = $a\->require_whole_object
\& Function: see below
\& Returns : a boolean flag
\& Args    : none
\& Status  : Internal
.Ve
.PP
This method returns true if the aggregator should refuse to aggregate
an object unless both its main part and its subparts are present.
.SS "match_sub"
.IX Subsection "match_sub"
.Vb 6
\& Title   : match_sub
\& Usage   : $coderef = $a\->match_sub($factory)
\& Function: generate a code reference that will match desired features
\& Returns : a code reference
\& Args    : see below
\& Status  : Internal
.Ve
.PP
This method is used internally to generate a code sub that will
quickly filter out the raw features that we're interested in
aggregating.  The returned sub accepts a Feature and returns true if
we should aggregate it, false otherwise.
.SS "strict_match"
.IX Subsection "strict_match"
.Vb 7
\& Title   : strict_match
\& Usage   : $strict = $a\->strict_match
\& Function: generate a hashref that indicates which subfeatures
\&           need to be tested strictly for matching sources before
\&           aggregating
\& Returns : a hash ref
\& Status  : Internal
.Ve
.SS "components"
.IX Subsection "components"
.Vb 6
\& Title   : components
\& Usage   : @array= $a\->components([$components])
\& Function: get/set stored list of parsed raw feature types
\& Returns : an array in list context, an array ref in scalar context
\& Args    : new arrayref of feature types
\& Status  : Internal
.Ve
.PP
This method is used internally to remember the parsed list of raw
features that we will aggregate.  The need for this subroutine is
seen when a user requests a composite feature of type
\&\*(L"clone:cosmid\*(R".  This generates a list of components in which the
source is appended to the method, like \*(L"clone_left_end:cosmid\*(R" and
\&\*(L"clone_right_end:cosmid\*(R".  \fIcomponents()\fR stores this information for
later use.
.SS "get_part_names"
.IX Subsection "get_part_names"
.Vb 6
\& Title   : get_part_names
\& Usage   : @array = $a\->get_part_names
\& Function: get list of sub\-parts for this type of feature
\& Returns : an array
\& Args    : none
\& Status  : Internal
.Ve
.PP
This method is used internally to fetch the list of feature types that
form the components of the composite feature.  Type names in the
format \*(L"method:source\*(R" are recognized, as are \*(L"method\*(R" and
Bio::DB::GFF::Typename objects as well.  It checks instance variables
first, and if not defined calls the \fIpart_names()\fR method.
.SS "get_main_name"
.IX Subsection "get_main_name"
.Vb 6
\& Title   : get_main_name
\& Usage   : $string = $a\->get_main_name
\& Function: get the "main" method type for this feature
\& Returns : a string
\& Args    : none
\& Status  : Internal
.Ve
.PP
This method is used internally to fetch the type of the \*(L"main part\*(R" of
the feature.  It checks instance variables first, and if not defined
calls the \fImain_name()\fR method.
.SS "get_method"
.IX Subsection "get_method"
.Vb 6
\& Title   : get_method
\& Usage   : $string = $a\->get_method
\& Function: get the method type for the composite feature
\& Returns : a string
\& Args    : none
\& Status  : Internal
.Ve
.PP
This method is used internally to fetch the type of the method that
will be assigned to the composite feature once it is synthesized.
.SH "BUGS"
.IX Header "BUGS"
None known yet.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::DB::GFF,
Bio::DB::GFF::Aggregator::alignment,
Bio::DB::GFF::Aggregator::clone,
Bio::DB::GFF::Aggregator::coding,
Bio::DB::GFF::Aggregator::match,
Bio::DB::GFF::Aggregator::processed_transcript,
Bio::DB::GFF::Aggregator::transcript,
Bio::DB::GFF::Aggregator::none
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2001 Cold Spring Harbor Laboratory.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
