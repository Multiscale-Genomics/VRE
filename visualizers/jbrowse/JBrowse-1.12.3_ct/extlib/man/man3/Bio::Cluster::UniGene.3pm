.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Cluster::UniGene 3"
.TH Bio::Cluster::UniGene 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Cluster::UniGene \- UniGene object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        use Bio::Cluster::UniGene;
\&        use Bio::ClusterIO;
\&
\&        $stream  = Bio::ClusterIO\->new(\*(Aq\-file\*(Aq => "Hs.data", 
\&                                       \*(Aq\-format\*(Aq => "unigene");
\&        # note: we quote \-format to keep older perl\*(Aqs from complaining.
\&
\&        while ( my $in = $stream\->next_cluster() ) {
\&                print $in\->unigene_id() . "\en";
\&                while ( my $sequence = $in\->next_seq() ) {
\&                        print $sequence\->accession_number() . "\en";
\&                }
\&       }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This UniGene object implements the Bio::Cluster::UniGeneI interface
for the representation if UniGene clusters in Bioperl. It is returned
by the Bio::ClusterIO parser for unigene format and contains all
the data associated with one UniGene record.
.PP
This class implements several interfaces and hence can be used
wherever instances of such interfaces are expected. In particular, the
interfaces are Bio::ClusterI as the base interface for all cluster
representations, and in addition Bio::IdentifiableI and
Bio::DescribableI.
.PP
The following lists the UniGene specific methods that are available
(see below for details). Be aware next_XXX iterators take a snapshot
of the array property when they are first called, and this snapshot is
not reset until the iterator is exhausted. Hence, once called you need
to exhaust the iterator to see any changes that have been made to the
property in the meantime. You will usually want to use the
non-iterator equivalents and loop over the elements yourself.
.PP
\&\fInew()\fR \- standard new call
.PP
\&\fIunigene_id()\fR \- set/get unigene_id
.PP
\&\fItitle()\fR \- set/get title (description)
.PP
\&\fIgene()\fR \- set/get gene
.PP
\&\fIcytoband()\fR \- set/get cytoband
.PP
\&\fImgi()\fR \- set/get mgi
.PP
\&\fIlocuslink()\fR \- set/get locuslink
.PP
\&\fIhomol()\fR \- set/get homologene
.PP
\&\fIgnm_terminus()\fR \- set/get gnm_terminus
.PP
\&\fIscount()\fR \- set/get scount
.PP
\&\fIexpress()\fR \- set/get express, currently takes/returns a reference to an
array of expressed tissues
.PP
\&\fInext_express()\fR \- returns the next tissue expression from the expressed
tissue array
.PP
\&\fIchromosome()\fR \- set/get chromosome, currently takes/returns a reference
to an array of chromosome lines
.PP
\&\fInext_chromosome()\fR \- returns the next chromosome line from the array of
chromosome lines
.PP
\&\fIsts()\fR \- set/get sts, currently takes/returns a reference to an array
of sts lines
.PP
\&\fInext_sts()\fR \- returns the next sts line from the array of sts lines
.PP
\&\fItxmap()\fR \- set/get txmap, currently takes/returns a reference to an
array of txmap lines
.PP
\&\fInext_txmap()\fR \- returns the next txmap line from the array of txmap
lines
.PP
\&\fIprotsim()\fR \- set/get protsim, currently takes/returns a reference to an
array of protsim lines
.PP
\&\fInext_protsim()\fR \- returns the next protsim line from the array of
protsim lines
.PP
\&\fIsequences()\fR \- set/get sequence, currently takes/returns a reference to
an array of references to seq info
.PP
\&\fInext_seq()\fR \- returns a Seq object that currently only contains an
accession number
.SH "Implemented Interfaces"
.IX Header "Implemented Interfaces"
This class implementes the following interfaces.
.IP "Bio::Cluster::UniGeneI" 4
.IX Item "Bio::Cluster::UniGeneI"
This includes implementing Bio::ClusterI.
.IP "Bio::IdentifiableI" 4
.IX Item "Bio::IdentifiableI"
.PD 0
.IP "Bio::DescribableI" 4
.IX Item "Bio::DescribableI"
.IP "Bio::AnnotatableI" 4
.IX Item "Bio::AnnotatableI"
.IP "Bio::Factory::SequenceStreamI" 4
.IX Item "Bio::Factory::SequenceStreamI"
.PD
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists. Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Andrew Macgregor"
.IX Header "AUTHOR - Andrew Macgregor"
Email andrew at cbbc.murdoch.edu.au
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Hilmar Lapp, hlapp at gmx.net
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a \*(L"_\*(R".
.SS "new"
.IX Subsection "new"
.Vb 3
\& Title   : new
\& Usage   : used by ClusterIO
\& Returns : a new Bio::Cluster::Unigene object
.Ve
.SH "Bio::Cluster::UniGeneI methods"
.IX Header "Bio::Cluster::UniGeneI methods"
.SS "unigene_id"
.IX Subsection "unigene_id"
.Vb 6
\& Title   : unigene_id
\& Usage   : unigene_id();
\& Function: Returns the unigene_id associated with the object.
\& Example : $id = $unigene\->unigene_id or $unigene\->unigene_id($id)
\& Returns : A string
\& Args    : None or an id
.Ve
.SS "title"
.IX Subsection "title"
.Vb 6
\& Title   : title
\& Usage   : title();
\& Function: Returns the title associated with the object.
\& Example : $title = $unigene\->title or $unigene\->title($title)
\& Returns : A string
\& Args    : None or a title
.Ve
.SS "gene"
.IX Subsection "gene"
.Vb 6
\& Title   : gene
\& Usage   : gene();
\& Function: Returns the gene associated with the object.
\& Example : $gene = $unigene\->gene or $unigene\->gene($gene)
\& Returns : A string
\& Args    : None or a gene
.Ve
.SS "cytoband"
.IX Subsection "cytoband"
.Vb 6
\& Title   : cytoband
\& Usage   : cytoband();
\& Function: Returns the cytoband associated with the object.
\& Example : $cytoband = $unigene\->cytoband or $unigene\->cytoband($cytoband)
\& Returns : A string
\& Args    : None or a cytoband
.Ve
.SS "mgi"
.IX Subsection "mgi"
.Vb 6
\& Title   : mgi
\& Usage   : mgi();
\& Function: Returns the mgi associated with the object.
\& Example : $mgi = $unigene\->mgi or $unigene\->mgi($mgi)
\& Returns : A string
\& Args    : None or a mgi
.Ve
.SS "locuslink"
.IX Subsection "locuslink"
.Vb 5
\& Title   : locuslink
\& Usage   : locuslink();
\& Function: Returns or stores a reference to an array containing locuslink data.
\& Returns : An array reference
\& Args    : None or an array reference
.Ve
.SS "homol"
.IX Subsection "homol"
.Vb 6
\& Title   : homol
\& Usage   : homol();
\& Function: Returns the homol entry associated with the object.
\& Example : $homol = $unigene\->homol or $unigene\->homol($homol)
\& Returns : A string
\& Args    : None or a homol entry
.Ve
.SS "restr_expr"
.IX Subsection "restr_expr"
.Vb 6
\& Title   : restr_expr
\& Usage   : restr_expr();
\& Function: Returns the restr_expr entry associated with the object.
\& Example : $restr_expr = $unigene\->restr_expr or $unigene\->restr_expr($restr_expr)
\& Returns : A string
\& Args    : None or a restr_expr entry
.Ve
.SS "gnm_terminus"
.IX Subsection "gnm_terminus"
.Vb 7
\& Title   : gnm_terminus
\& Usage   : gnm_terminus();
\& Function: Returns the gnm_terminus associated with the object.
\& Example : $gnm_terminus = $unigene\->gnm_terminus or 
\&           $unigene\->gnm_terminus($gnm_terminus)
\& Returns : A string
\& Args    : None or a gnm_terminus
.Ve
.SS "scount"
.IX Subsection "scount"
.Vb 6
\& Title   : scount
\& Usage   : scount();
\& Function: Returns the scount associated with the object.
\& Example : $scount = $unigene\->scount or $unigene\->scount($scount)
\& Returns : A string
\& Args    : None or a scount
.Ve
.SS "express"
.IX Subsection "express"
.Vb 6
\& Title   : express
\& Usage   : express();
\& Function: Returns or stores a reference to an array containing 
\&           tissue expression data
\& Returns : An array reference
\& Args    : None or an array reference
.Ve
.SS "chromosome"
.IX Subsection "chromosome"
.Vb 6
\& Title   : chromosome
\& Usage   : chromosome();
\& Function: Returns or stores a reference to an array containing
\&           chromosome lines
\& Returns : An array reference
\& Args    : None or an array reference
.Ve
.SS "sts"
.IX Subsection "sts"
.Vb 3
\& Title   : sts
\& Usage   : sts();
\& Function: Returns or stores a reference to an array containing sts lines
\&
\& Returns : An array reference
\& Args    : None or an array reference
.Ve
.SS "txmap"
.IX Subsection "txmap"
.Vb 3
\& Title   : txmap
\& Usage   : txmap();
\& Function: Returns or stores a reference to an array containing txmap lines
\&
\& Returns : An array reference
\& Args    : None or an array reference
.Ve
.SS "protsim"
.IX Subsection "protsim"
.Vb 6
\& Title   : protsim
\& Usage   : protsim();
\& Function: Returns or stores a reference to an array containing protsim lines
\&           This should really only be used by ClusterIO, not directly
\& Returns : An array reference
\& Args    : None or an array reference
.Ve
.SS "sequences"
.IX Subsection "sequences"
.Vb 4
\& Title   : sequences
\& Usage   : sequences();
\& Function: Returns or stores a reference to an array containing
\&           sequence data.
\&
\&           This is mostly reserved for ClusterIO parsers. You should
\&           use get_members() for get and add_member()/remove_members()
\&           for set.
\&
\& Returns : An array reference, or undef
\& Args    : None or an array reference or undef
.Ve
.SS "species"
.IX Subsection "species"
.Vb 7
\& Title   : species
\& Usage   : $obj\->species($newval)
\& Function: Get/set the species object for this Unigene cluster.
\& Example : 
\& Returns : value of species (a L<Bio::Species> object)
\& Args    : on set, new value (a L<Bio::Species> object or 
\&           the binomial name, or undef, optional)
.Ve
.SH "Bio::ClusterI methods"
.IX Header "Bio::ClusterI methods"
.SS "display_id"
.IX Subsection "display_id"
.Vb 3
\& Title   : display_id
\& Usage   : 
\& Function: Get/set the display name or identifier for the cluster
\&
\&           This is aliased to unigene_id().
\&
\& Returns : a string
\& Args    : optional, on set the display ID ( a string)
.Ve
.SS "description"
.IX Subsection "description"
.Vb 3
\& Title   : description
\& Usage   : Bio::ClusterI\->description("POLYUBIQUITIN")
\& Function: get/set for the consensus description of the cluster
\&
\&           This is aliased to title().
\&
\& Returns : the description string 
\& Args    : Optional the description string
.Ve
.SS "size"
.IX Subsection "size"
.Vb 4
\& Title   : size
\& Usage   : Bio::ClusterI\->size();
\& Function: get for the size of the family, 
\&           calculated from the number of members
\&
\&           This is aliased to scount().
\&
\& Returns : the size of the cluster
\& Args    :
.Ve
.SS "cluster_score"
.IX Subsection "cluster_score"
.Vb 5
\& Title   : cluster_score
\& Usage   : $cluster \->cluster_score(100);
\& Function: get/set for cluster_score which
\&           represent the score in which the clustering
\&           algorithm assigns to this cluster.
\&
\&           For UniGene clusters, there really is no cluster score that
\&           would come with the data. However, we provide an
\&           implementation here so that you can score UniGene clusters
\&           if you want to.
\&
\& Returns : a number
\& Args    : optionally, on set a number
.Ve
.SS "get_members"
.IX Subsection "get_members"
.Vb 3
\& Title   : get_members
\& Usage   : Bio::ClusterI\->get_members(($seq1, $seq2));
\& Function: retrieve the members of the family by some criteria
\&
\&           Will return all members if no criteria are provided.
\&
\&           At this time this implementation does not support
\&           specifying criteria and will always return all members.
\&
\& Returns : the array of members
\& Args    :
.Ve
.SH "Annotatable view at the object properties"
.IX Header "Annotatable view at the object properties"
.SS "annotation"
.IX Subsection "annotation"
.Vb 4
\& Title   : annotation
\& Usage   : $obj\->annotation($newval)
\& Function: Get/set the L<Bio::AnnotationCollectionI> object for
\&           this UniGene cluster.
\&
\&           Many attributes of this class are actually stored within
\&           the annotation collection object as L<Bio::AnnotationI>
\&           compliant objects, so you can conveniently access them
\&           through the same interface as you would e.g. access
\&           L<Bio::SeqI> annotation properties.
\&
\&           If you call this method in set mode and replace the
\&           annotation collection with another one you should know
\&           exactly what you are doing.
\&
\& Example : 
\& Returns : a L<Bio::AnnotationCollectionI> compliant object
\& Args    : on set, new value (a L<Bio::AnnotationCollectionI> 
\&           compliant object or undef, optional)
.Ve
.SH "Implementation specific methods"
.IX Header "Implementation specific methods"
.Vb 2
\& These are mostly for adding/removing to array properties, and for
\& methods with special functionality.
.Ve
.SS "add_member"
.IX Subsection "add_member"
.Vb 7
\& Title   : add_member
\& Usage   :
\& Function: Adds a member object to the list of members.
\& Example :
\& Returns : TRUE if the new member was successfully added, and FALSE
\&           otherwise.
\& Args    : The member to add.
.Ve
.SS "remove_members"
.IX Subsection "remove_members"
.Vb 7
\& Title   : remove_members
\& Usage   :
\& Function: Remove the list of members for this cluster such that the
\&           member list is undefined afterwards (as opposed to zero members).
\& Example :
\& Returns : the previous list of members
\& Args    : none
.Ve
.SS "next_locuslink"
.IX Subsection "next_locuslink"
.Vb 4
\& Title   : next_locuslink
\& Usage   : next_locuslink();
\& Function: Returns the next locuslink from an array referred 
\&           to using $obj\->{\*(Aqlocuslink\*(Aq}
\&
\&           If you call this iterator again after it returned undef, it
\&           will re\-cycle through the list of elements. Changes in the
\&           underlying array property while you loop over this iterator
\&           will not be reflected until you exhaust the iterator.
\&
\& Example :      while ( my $locuslink = $in\->next_locuslink() ) {
\&                                print "$locuslink\en";
\&                        }
\& Returns : String
\& Args    : None
.Ve
.SS "next_express"
.IX Subsection "next_express"
.Vb 4
\& Title   : next_express
\& Usage   : next_express();
\& Function: Returns the next tissue from an array referred 
\&           to using $obj\->{\*(Aqexpress\*(Aq}
\&
\&           If you call this iterator again after it returned undef, it
\&           will re\-cycle through the list of elements. Changes in the
\&           underlying array property while you loop over this iterator
\&           will not be reflected until you exhaust the iterator.
\&
\& Example :      while ( my $express = $in\->next_express() ) {
\&                                print "$express\en";
\&                        }
\& Returns : String
\& Args    : None
.Ve
.SS "next_chromosome"
.IX Subsection "next_chromosome"
.Vb 4
\& Title   : next_chromosome
\& Usage   : next_chromosome();
\& Function: Returns the next chromosome line from an array referred
\&           to using $obj\->{\*(Aqchromosome\*(Aq}
\&
\&           If you call this iterator again after it returned undef, it
\&           will re\-cycle through the list of elements. Changes in the
\&           underlying array property while you loop over this iterator
\&           will not be reflected until you exhaust the iterator.
\&
\& Example :      while ( my $chromosome = $in\->next_chromosome() ) {
\&                                print "$chromosome\en";
\&                        }
\& Returns : String
\& Args    : None
.Ve
.SS "next_protsim"
.IX Subsection "next_protsim"
.Vb 4
\& Title   : next_protsim
\& Usage   : next_protsim();
\& Function: Returns the next protsim line from an array referred 
\&           to using $obj\->{\*(Aqprotsim\*(Aq}
\&
\&           If you call this iterator again after it returned undef, it
\&           will re\-cycle through the list of elements. Changes in the
\&           underlying array property while you loop over this iterator
\&           will not be reflected until you exhaust the iterator.
\&
\& Example :      while ( my $protsim = $in\->next_protsim() ) {
\&                                print "$protsim\en";
\&                        }
\& Returns : String
\& Args    : None
.Ve
.SS "next_sts"
.IX Subsection "next_sts"
.Vb 4
\& Title   : next_sts
\& Usage   : next_sts();
\& Function: Returns the next sts line from an array referred 
\&           to using $obj\->{\*(Aqsts\*(Aq}
\&
\&           If you call this iterator again after it returned undef, it
\&           will re\-cycle through the list of elements. Changes in the
\&           underlying array property while you loop over this iterator
\&           will not be reflected until you exhaust the iterator.
\&
\& Example :      while ( my $sts = $in\->next_sts() ) {
\&                                print "$sts\en";
\&                        }
\& Returns : String
\& Args    : None
.Ve
.SS "next_txmap"
.IX Subsection "next_txmap"
.Vb 4
\& Title   : next_txmap
\& Usage   : next_txmap();
\& Function: Returns the next txmap line from an array 
\&           referred to using $obj\->{\*(Aqtxmap\*(Aq}
\&
\&           If you call this iterator again after it returned undef, it
\&           will re\-cycle through the list of elements. Changes in the
\&           underlying array property while you loop over this iterator
\&           will not be reflected until you exhaust the iterator.
\&
\& Example :      while ( my $tsmap = $in\->next_txmap() ) {
\&                                print "$txmap\en";
\&                        }
\& Returns : String
\& Args    : None
.Ve
.SH "Bio::IdentifiableI methods"
.IX Header "Bio::IdentifiableI methods"
.SS "object_id"
.IX Subsection "object_id"
.Vb 5
\& Title   : object_id
\& Usage   : $string    = $obj\->object_id()
\& Function: a string which represents the stable primary identifier
\&           in this namespace of this object. For DNA sequences this
\&           is its accession_number, similarly for protein sequences
\&
\&           This is aliased to unigene_id().
\&
\& Returns : A scalar
.Ve
.SS "version"
.IX Subsection "version"
.Vb 6
\& Title   : version
\& Usage   : $version    = $obj\->version()
\& Function: a number which differentiates between versions of
\&           the same object. Higher numbers are considered to be
\&           later and more relevant, but a single object described
\&           the same identifier should represent the same concept
\&
\&           Unigene clusters usually won\*(Aqt have a version, so this
\&           will be mostly undefined.
\&
\& Returns : A number
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "authority"
.IX Subsection "authority"
.Vb 5
\& Title   : authority
\& Usage   : $authority    = $obj\->authority()
\& Function: a string which represents the organisation which
\&           granted the namespace, written as the DNS name for  
\&           organisation (eg, wormbase.org)
\&
\& Returns : A scalar
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "namespace"
.IX Subsection "namespace"
.Vb 5
\& Title   : namespace
\& Usage   : $string    = $obj\->namespace()
\& Function: A string representing the name space this identifier
\&           is valid in, often the database name or the name
\&           describing the collection 
\&
\& Returns : A scalar
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SH "Bio::DescribableI methods"
.IX Header "Bio::DescribableI methods"
.SS "display_name"
.IX Subsection "display_name"
.Vb 7
\& Title   : display_name
\& Usage   : $string    = $obj\->display_name()
\& Function: A string which is what should be displayed to the user
\&           the string should have no spaces (ideally, though a cautious
\&           user of this interface would not assume this) and should be
\&           less than thirty characters (though again, double checking 
\&           this is a good idea)
\&
\&           This is aliased to unigene_id().
\&
\& Returns : A scalar
\& Status  : Virtual
.Ve
.SS "\fIdescription()\fP"
.IX Subsection "description()"
.Vb 8
\& Title   : description
\& Usage   : $string    = $obj\->description()
\& Function: A text string suitable for displaying to the user a 
\&           description. This string is likely to have spaces, but
\&           should not have any newlines or formatting \- just plain
\&           text. The string should not be greater than 255 characters
\&           and clients can feel justified at truncating strings at 255
\&           characters for the purposes of display
\&
\&           This is already demanded by Bio::ClusterI and hence is
\&           present anyway.
\&
\& Returns : A scalar
.Ve
.SH "Bio::Factory::SequenceStreamI methods"
.IX Header "Bio::Factory::SequenceStreamI methods"
.SS "next_seq"
.IX Subsection "next_seq"
.Vb 6
\& Title   : next_seq
\& Usage   : next_seq();
\& Function: Returns the next seq as a Seq object as defined by 
\&           $seq\->sequence_factory(), 
\&           at present an empty Bio::Seq::RichSeq object with 
\&           just the accession_number() and pid() set
\&
\&           This iterator will not exhaust the array of member
\&           sequences. If you call next_seq() again after it returned
\&           undef, it will re\-cycle through the list of member
\&           sequences.
\&
\& Example :  while ( my $sequence = $in\->next_seq() ) {
\&             print $sequence\->accession_number() . "\en";
\&            }
\& Returns : Bio::PrimarySeqI object
\& Args    : None
.Ve
.SS "sequence_factory"
.IX Subsection "sequence_factory"
.Vb 5
\& Title   : sequence_factory
\& Usage   : $seqio\->sequence_factory($seqfactory)
\& Function: Get/Set the Bio::Factory::SequenceFactoryI
\& Returns : Bio::Factory::SequenceFactoryI
\& Args    : [optional] Bio::Factory::SequenceFactoryI
.Ve
.SH "Private methods"
.IX Header "Private methods"
.SS "_annotation_value"
.IX Subsection "_annotation_value"
.Vb 7
\& Title   : _annotation_value
\& Usage   :
\& Function: Private method.
\& Example :
\& Returns : the value (a string)
\& Args    : annotation key (a string)
\&           on set, annotation value (a string)
.Ve
.SS "_annotation_value_ary"
.IX Subsection "_annotation_value_ary"
.Vb 7
\& Title   : _annotation_value_ary
\& Usage   :
\& Function: Private method.
\& Example :
\& Returns : reference to the array of values
\& Args    : annotation key (a string)
\&           on set, reference to an array holding the values
.Ve
.SS "_annotation_dblink"
.IX Subsection "_annotation_dblink"
.Vb 8
\& Title   : _annotation_dblink
\& Usage   :
\& Function: Private method.
\& Example :
\& Returns : array of accessions for the given database (namespace)
\& Args    : annotation key (a string)
\&           dbname (a string) (optional on get, mandatory on set)
\&           on set, accession or ID (a string), and version
.Ve
.SS "_remove_dblink"
.IX Subsection "_remove_dblink"
.Vb 7
\& Title   : _remove_dblink
\& Usage   :
\& Function: Private method.
\& Example :
\& Returns : array of accessions for the given database (namespace)
\& Args    : annotation key (a string)
\&           dbname (a string) (optional)
.Ve
