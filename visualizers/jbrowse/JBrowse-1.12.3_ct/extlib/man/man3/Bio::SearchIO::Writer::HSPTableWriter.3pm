.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::SearchIO::Writer::HSPTableWriter 3"
.TH Bio::SearchIO::Writer::HSPTableWriter 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::SearchIO::Writer::HSPTableWriter \- Tab\-delimited data for Bio::Search::HSP::HSPI objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Example 1: Using the default columns"
.IX Subsection "Example 1: Using the default columns"
.Vb 2
\&    use Bio::SearchIO;
\&    use Bio::SearchIO::Writer::HSPTableWriter;
\&
\&    my $in = Bio::SearchIO\->new();
\&
\&    my $writer = Bio::SearchIO::Writer::HSPTableWriter\->new();
\&
\&    my $out = Bio::SearchIO\->new( \-writer => $writer );
\&
\&    while ( my $result = $in\->next_result() ) {
\&        $out\->write_result($result, ($in\->report_count \- 1 ? 0 : 1) );
\&    }
.Ve
.SS "Example 2: Specifying a subset of columns"
.IX Subsection "Example 2: Specifying a subset of columns"
.Vb 2
\&    use Bio::SearchIO;
\&    use Bio::SearchIO::Writer::HSPTableWriter;
\&
\&    my $in = Bio::SearchIO\->new();
\&
\&    my $writer = Bio::SearchIO::Writer::HSPTableWriter\->new( 
\&                                  \-columns => [qw(
\&                                                  query_name
\&                                                  query_length
\&                                                  hit_name
\&                                                  hit_length
\&                                                  rank
\&                                                  frac_identical_query
\&                                                  expect
\&                                                  )]  );
\&
\&    my $out = Bio::SearchIO\->new( \-writer => $writer,
\&                                  \-file   => ">searchio.out" );
\&
\&    while ( my $result = $in\->next_result() ) {
\&        $out\->write_result($result, ($in\->report_count \- 1 ? 0 : 1) );
\&    }
.Ve
.SS "Custom Labels"
.IX Subsection "Custom Labels"
You can also specify different column labels if you don't want to use
the defaults.  Do this by specifying a \f(CW\*(C`\-labels\*(C'\fR hash reference
parameter when creating the HSPTableWriter object.  The keys of the
hash should be the column number (left-most column = 1) for the label(s)
you want to specify. Here's an example:
.PP
.Vb 7
\&    my $writer = Bio::SearchIO::Writer::HSPTableWriter\->new( 
\&                               \-columns => [qw( query_name 
\&                                                query_length
\&                                                hit_name
\&                                                hit_length  )],
\&                               \-labels  => { 1 => \*(AqQUERY_GI\*(Aq,
\&                                             3 => \*(AqHIT_IDENTIFIER\*(Aq } );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::SearchIO::Writer::HSPTableWriter generates output at the finest
level of granularity for data within a search result. Data for each \s-1HSP\s0
within each hit in a search result is output in tab-delimited format,
one row per \s-1HSP.\s0
.SS "Available Columns"
.IX Subsection "Available Columns"
Here are the columns that can be specified in the \f(CW\*(C`\-columns\*(C'\fR
parameter when creating a HSPTableWriter object.  If a \f(CW\*(C`\-columns\*(C'\fR parameter
is not specified, this list, in this order, will be used as the default.
.PP
.Vb 10
\&    query_name             # Sequence identifier of the query.
\&    query_length           # Full length of the query sequence
\&    hit_name               # Sequence identifier of the hit
\&    hit_length             # Full length of the hit sequence
\&    round                  # Round number for hit (PSI\-BLAST)
\&    rank
\&    expect                 # Expect value for the alignment
\&    score                  # Score for the alignment (e.g., BLAST score)
\&    bits                   # Bit score for the alignment
\&    frac_identical_query   # fraction of identical substitutions in query
\&    frac_identical_hit     # fraction of identical substitutions in hit
\&    frac_conserved_query   # fraction of conserved substitutions in query
\&    frac_conserved_hit     # fraction of conserved substitutions in hit
\&    length_aln_query       # Length of the aligned portion of the query sequence
\&    length_aln_hit         # Length of the aligned portion of the hit sequence
\&    gaps_query             # Number of gap characters in the aligned query sequence
\&    gaps_hit               # Number of gap characters in the aligned hit sequence
\&    gaps_total             # Number of gap characters in the aligned query and hit sequences
\&    start_query            # Starting coordinate of the aligned portion of the query sequence
\&    end_query              # Ending coordinate of the aligned portion of the query sequence
\&    start_hit              # Starting coordinate of the aligned portion of the hit sequence
\&    end_hit                # Ending coordinate of the aligned portion of the hit sequence
\&    strand_query           # Strand of the aligned query sequence
\&    strand_hit             # Strand of the aligned hit sequence
\&    frame                  # Reading frame of the aligned query sequence 
\&    hit_description        # Full description of the hit sequence
\&    query_description      # Full description of the query sequence
\&    frac_identical_total   # fraction of total identical substitutions
\&    frac_conserved_total   # fraction of total conserved substitutions
.Ve
.PP
For more details about these columns, see the documentation for the
corresponding method in Bio::Search::HSP::HSPI.
.SH "TODO"
.IX Header "TODO"
Figure out the best way to incorporate algorithm-specific score columns.
The best route is probably to have algorith-specific subclasses 
(e.g., BlastHSPTableWriter, FastaHSPTableWriter).
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules.  Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Chervitz <sac@bioperl.org>
.PP
See the \s-1FEEDBACK\s0 section  for where to send bug reports
and comments.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001 Steve Chervitz. All Rights Reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This software is provided \*(L"as is\*(R" without warranty of any kind.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 2
\&    Bio::SearchIO::Writer::HitTableWriter
\&    Bio::SearchIO::Writer::ResultTableWriter
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIto_string()\fP"
.IX Subsection "to_string()"
Note: this method is not intended for direct use. 
The \fISearchIO::write_result()\fR method calls it automatically 
if the writer is hooked up to a SearchIO object as illustrated in
the \s-1SYNOPSIS\s0 section .
.PP
.Vb 11
\& Title     : to_string()
\&           :
\& Usage     : print $writer\->to_string( $result_obj, [$include_labels] );
\&           :
\& Argument  : $result_obj = A Bio::Search::Result::ResultI object
\&           : $include_labels = boolean, if true column labels are included (default: false)
\&           :
\& Returns   : String containing tab\-delimited set of data for each HSP
\&           : in each Hit of the supplied ResultI object. 
\&           :
\& Throws    : n/a
.Ve
.SS "end_report"
.IX Subsection "end_report"
.Vb 8
\& Title   : end_report
\& Usage   : $self\->end_report()
\& Function: The method to call when ending a report, this is
\&           mostly for cleanup for formats which require you to 
\&           have something at the end of the document.  Nothing for
\&           a text message.
\& Returns : string
\& Args    : none
.Ve
.SS "filter"
.IX Subsection "filter"
.Vb 6
\& Title   : filter
\& Usage   : $writer\->filter(\*(Aqhsp\*(Aq, \e&hsp_filter);
\& Function: Filter out either at HSP,Hit,or Result level
\& Returns : none
\& Args    : string => data type,
\&           CODE reference
.Ve
