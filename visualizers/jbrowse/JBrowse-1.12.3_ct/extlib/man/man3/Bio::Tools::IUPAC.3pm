.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::IUPAC 3"
.TH Bio::Tools::IUPAC 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tools::IUPAC \- Generates unique sequence objects or regular expressions from
an ambiguous IUPAC sequence
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Bio::PrimarySeq;
\& use Bio::Tools::IUPAC;
\&
\& # Get the IUPAC code for proteins
\& my %iupac_prot = Bio::Tools::IUPAC\->new\->iupac_iup;
\&
\& # Create a sequence with degenerate residues
\& my $ambiseq = Bio::PrimarySeq\->new(\-seq => \*(AqARTCGUTGN\*(Aq, \-alphabet => \*(Aqdna\*(Aq);
\&
\& # Create all possible non\-degenerate sequences
\& my $iupac = Bio::Tools::IUPAC\->new(\-seq => $ambiseq);
\& while ($uniqueseq = $iupac\->next_seq()) {
\&     # process the unique Bio::Seq object.
\& }
\&
\& # Get a regular expression that matches all possible sequences
\& my $regexp = $iupac\->regexp();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::Tools::IUPAC is a tool that manipulates sequences with ambiguous residues
following the \s-1IUPAC\s0 conventions. Non-standard characters have the meaning 
described below:
.PP
.Vb 2
\&    IUPAC\-IUB SYMBOLS FOR NUCLEOTIDE (DNA OR RNA) NOMENCLATURE:
\&      Cornish\-Bowden (1985) Nucl. Acids Res. 13: 3021\-3030
\&
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    Symbol       Meaning      Nucleic Acid
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     A            A           Adenine
\&     C            C           Cytosine
\&     G            G           Guanine
\&     T            T           Thymine
\&     U            U           Uracil
\&     M          A or C        aMino
\&     R          A or G        puRine
\&     W          A or T        Weak
\&     S          C or G        Strong
\&     Y          C or T        pYrimidine
\&     K          G or T        Keto
\&     V        A or C or G     not T (closest unused char after T)
\&     H        A or C or T     not G (closest unused char after G)
\&     D        A or G or T     not C (closest unused char after C)
\&     B        C or G or T     not A (closest unused char after A)
\&     X      G or A or T or C  Unknown (very rarely used)
\&     N      G or A or T or C  Unknown (commonly used)
\&
\&
\&    IUPAC\-IUP AMINO ACID SYMBOLS:
\&      Biochem J. 1984 Apr 15; 219(2): 345\-373
\&      Eur J Biochem. 1993 Apr 1; 213(1): 2
\&
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    Symbol           Meaning
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    A        Alanine
\&    B        Aspartic Acid, Asparagine
\&    C        Cysteine
\&    D        Aspartic Acid
\&    E        Glutamic Acid
\&    F        Phenylalanine
\&    G        Glycine
\&    H        Histidine
\&    I        Isoleucine
\&    J        Isoleucine/Leucine
\&    K        Lysine
\&    L        Leucine
\&    M        Methionine
\&    N        Asparagine
\&    O        Pyrrolysine
\&    P        Proline
\&    Q        Glutamine
\&    R        Arginine
\&    S        Serine
\&    T        Threonine
\&    U        Selenocysteine
\&    V        Valine
\&    W        Tryptophan
\&    X        Unknown
\&    Y        Tyrosine
\&    Z        Glutamic Acid, Glutamine
\&    *        Terminator
.Ve
.PP
There are a few things Bio::Tools::IUPAC can do for you:
.IP "\(bu" 4
report the \s-1IUPAC\s0 mapping between ambiguous and non-ambiguous residues
.IP "\(bu" 4
produce a stream of all possible corresponding unambiguous Bio::Seq objects given
an ambiguous sequence object
.IP "\(bu" 4
convert an ambiguous sequence object to a corresponding regular expression
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Aaron Mackey"
.IX Header "AUTHOR - Aaron Mackey"
Email amackey\-at\-virginia.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : Bio::Tools::IUPAC\->new($seq);
\& Function: Create a new IUPAC object, which acts as a sequence stream (akin to
\&           SeqIO)
\& Args    : an ambiguously coded sequence object that has a specified \*(Aqalphabet\*(Aq
\& Returns : a Bio::Tools::IUPAC object.
.Ve
.SS "next_seq"
.IX Subsection "next_seq"
.Vb 5
\& Title   : next_seq
\& Usage   : $iupac\->next_seq();
\& Function: returns the next unique sequence object
\& Args    : none.
\& Returns : a Bio::Seq object
.Ve
.SS "iupac"
.IX Subsection "iupac"
.Vb 8
\& Title   : iupac
\& Usage   : my %symbols = $iupac\->iupac;
\& Function: Returns a hash of symbols \-> symbol components of the right type
\&           for the given sequence, i.e. it is the same as iupac_iup() if
\&           Bio::Tools::IUPAC was given a proteic sequence, or iupac_iub() if the 
\&           sequence was nucleic. For example, the key \*(AqM\*(Aq has the value [\*(AqA\*(Aq, \*(AqC\*(Aq].
\& Args    : none
\& Returns : Hash
.Ve
.SS "iupac_amb"
.IX Subsection "iupac_amb"
.Vb 8
\& Title   : iupac_amb
\& Usage   : my %symbols = $iupac\->iupac_amb;
\& Function: Same as iupac() but only contains a mapping between ambiguous residues
\&           and the ambiguous residues they map to. For example, the key \*(AqN\*(Aq has
\&           the value [\*(AqR\*(Aq, \*(AqY\*(Aq, \*(AqK\*(Aq, \*(AqM\*(Aq, \*(AqS\*(Aq, \*(AqW\*(Aq, \*(AqB\*(Aq, \*(AqD\*(Aq, \*(AqH\*(Aq, \*(AqV\*(Aq, \*(AqN\*(Aq],
\&           i.e. it matches all other ambiguous residues.
\& Args    : none
\& Returns : Hash
.Ve
.SS "iupac_iup"
.IX Subsection "iupac_iup"
.Vb 5
\& Title   : iupac_iup
\& Usage   : my %aasymbols = $iupac\->iupac_iup;
\& Function: Returns a hash of PROTEIN symbols \-> non\-ambiguous symbol components
\& Args    : none
\& Returns : Hash
.Ve
.SS "iupac_iup_amb"
.IX Subsection "iupac_iup_amb"
.Vb 5
\& Title   : iupac_iup_amb
\& Usage   : my %aasymbols = $iupac\->iupac_iup_amb;
\& Function: Returns a hash of PROTEIN symbols \-> ambiguous symbol components
\& Args    : none
\& Returns : Hash
.Ve
.SS "iupac_iub"
.IX Subsection "iupac_iub"
.Vb 5
\& Title   : iupac_iub
\& Usage   : my %dnasymbols = $iupac\->iupac_iub;
\& Function: Returns a hash of DNA symbols \-> non\-ambiguous symbol components
\& Args    : none
\& Returns : Hash
.Ve
.SS "iupac_iub_amb"
.IX Subsection "iupac_iub_amb"
.Vb 5
\& Title   : iupac_iub_amb
\& Usage   : my %dnasymbols = $iupac\->iupac_iub;
\& Function: Returns a hash of DNA symbols \-> ambiguous symbol components
\& Args    : none
\& Returns : Hash
.Ve
.SS "iupac_rev_iub"
.IX Subsection "iupac_rev_iub"
.Vb 6
\& Title   : iupac_rev_iub
\& Usage   : my %dnasymbols = $iupac\->iupac_rev_iub;
\& Function: Returns a hash of nucleotide combinations \-> IUPAC code
\&           (a reverse of the iupac_iub hash).
\& Args    : none
\& Returns : Hash
.Ve
.SS "count"
.IX Subsection "count"
.Vb 6
\& Title   : count
\& Usage   : my $total = $iupac\->count();
\& Function: Calculates the number of unique, unambiguous sequences that
\&           this ambiguous sequence could generate
\& Args    : none
\& Return  : int
.Ve
.SS "regexp"
.IX Subsection "regexp"
.Vb 11
\& Title   : regexp
\& Usage   : my $re = $iupac\->regexp();
\& Function: Converts the ambiguous sequence into a regular expression that
\&           matches all of the corresponding ambiguous and non\-ambiguous sequences.
\&           You can further manipulate the resulting regular expression with the
\&           Bio::Tools::SeqPattern module. After you are done building your
\&           regular expression, you might want to compile it and make it case\-
\&           insensitive:
\&              $re = qr/$re/i;
\& Args    : 1 to match RNA: T and U characters will match interchangeably
\& Return  : regular expression
.Ve
