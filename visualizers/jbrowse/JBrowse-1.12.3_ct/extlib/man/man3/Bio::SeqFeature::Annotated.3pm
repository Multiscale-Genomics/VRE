.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::SeqFeature::Annotated 3pm"
.TH Bio::SeqFeature::Annotated 3pm "2014-09-05" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::SeqFeature::Annotated \- PLEASE PUT SOMETHING HERE
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # none yet, complain to authors
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
None yet, complain to authors.
.SH "Implemented Interfaces"
.IX Header "Implemented Interfaces"
This class implements the following interfaces.
.IP "Bio::SeqFeatureI" 4
.IX Item "Bio::SeqFeatureI"
Note that this includes implementing Bio::RangeI.
.IP "Bio::AnnotatableI" 4
.IX Item "Bio::AnnotatableI"
.PD 0
.IP "Bio::FeatureHolderI" 4
.IX Item "Bio::FeatureHolderI"
.PD
Features held by a feature are essentially sub-features.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via 
the web:
.PP
.Vb 1
\&  http://bugzilla.open\-bio.org/
.Ve
.SH "AUTHOR \- Allen Day"
.IX Header "AUTHOR - Allen Day"
Allen Day <allenday at ucla.edu>
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SH "PREAMBLE"
.IX Header "PREAMBLE"
Okay, where to start...
.PP
The original idea for this class appears to lump all SeqFeatureI data
(primary_tag, source_tag, etc) into AnnotationI objects into an
Bio::Annotation::Collection. The type is then checked against \s-1SOFA.\s0
.PP
There have been several requests to have type checking be optionally run.
.PP
Bio::FeatureHolderI::create_hierarchy_from_ParentIDs
Bio::FeatureHolderI::feature_count
Bio::FeatureHolderI::get_all_SeqFeatures
Bio::FeatureHolderI::set_ParentIDs_from_hierarchy
Bio::RangeI::contains
Bio::RangeI::disconnected_ranges
Bio::RangeI::equals
Bio::RangeI::intersection
Bio::RangeI::offsetStranded
Bio::RangeI::overlap_extent
Bio::RangeI::overlaps
Bio::RangeI::subtract
Bio::RangeI::union
Bio::SeqFeature::Annotated::Dumper
Bio::SeqFeature::Annotated::MAX_TYPE_CACHE_MEMBERS
Bio::SeqFeature::Annotated::add_Annotation
Bio::SeqFeature::Annotated::add_SeqFeature
Bio::SeqFeature::Annotated::add_tag_value
Bio::SeqFeature::Annotated::add_target
Bio::SeqFeature::Annotated::annotation
Bio::SeqFeature::Annotated::attach_seq
Bio::SeqFeature::Annotated::display_name
Bio::SeqFeature::Annotated::each_target
Bio::SeqFeature::Annotated::end
Bio::SeqFeature::Annotated::entire_seq
Bio::SeqFeature::Annotated::frame
Bio::SeqFeature::Annotated::from_feature
Bio::SeqFeature::Annotated::get_Annotations
Bio::SeqFeature::Annotated::get_SeqFeatures
Bio::SeqFeature::Annotated::get_all_tags
Bio::SeqFeature::Annotated::get_tag_values
Bio::SeqFeature::Annotated::get_tagset_values
Bio::SeqFeature::Annotated::has_tag
Bio::SeqFeature::Annotated::length
Bio::SeqFeature::Annotated::location
Bio::SeqFeature::Annotated::name
Bio::SeqFeature::Annotated::new
Bio::SeqFeature::Annotated::phase
Bio::SeqFeature::Annotated::primary_tag
Bio::SeqFeature::Annotated::remove_Annotations
Bio::SeqFeature::Annotated::remove_SeqFeatures
Bio::SeqFeature::Annotated::remove_tag
Bio::SeqFeature::Annotated::score
Bio::SeqFeature::Annotated::seq
Bio::SeqFeature::Annotated::seq_id
Bio::SeqFeature::Annotated::source
Bio::SeqFeature::Annotated::source_tag
Bio::SeqFeature::Annotated::start
Bio::SeqFeature::Annotated::strand
Bio::SeqFeature::Annotated::type
Bio::SeqFeature::Annotated::uri_escape
Bio::SeqFeature::Annotated::uri_unescape
Bio::SeqFeature::TypedSeqFeatureI::croak
Bio::SeqFeature::TypedSeqFeatureI::ontology_term
Bio::SeqFeatureI::generate_unique_persistent_id
Bio::SeqFeatureI::gff_string
Bio::SeqFeatureI::primary_id
Bio::SeqFeatureI::spliced_seq
.SH "ATTRIBUTE ACCESSORS FOR Bio::SeqFeature::Annotated"
.IX Header "ATTRIBUTE ACCESSORS FOR Bio::SeqFeature::Annotated"
.SS "from_feature"
.IX Subsection "from_feature"
.Vb 8
\&  Usage: $obj\->from_feature($myfeature);
\&  Desc : initialize this object with the contents of another feature
\&         object.  Useful for converting objects like
\&         L<Bio::SeqFeature::Generic> to this class
\&  Ret  : nothing meaningful
\&  Args : a single object of some other feature type,
\&  Side Effects: throws error on failure
\&  Example:
.Ve
.SS "\fIseq_id()\fP"
.IX Subsection "seq_id()"
.Vb 6
\& Usage   : $obj\->seq_id($newval)
\& Function: holds a string corresponding to the unique
\&           seq_id of the sequence underlying the feature
\&           (e.g. database accession or primary key).
\& Returns : string representing the seq_id.
\& Args    : on set, some string or a Bio::Annotation::SimpleValue object.
.Ve
.SS "\fIname()\fP"
.IX Subsection "name()"
.Vb 4
\& Usage   : $obj\->name($newval)
\& Function: human\-readable name for the feature.
\& Returns : value of name (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "\fItype()\fP"
.IX Subsection "type()"
.Vb 6
\& Usage   : $obj\->type($newval)
\& Function: a SOFA type for the feature.
\& Returns : Bio::Annotation::OntologyTerm object representing the type.
\&           NB: to get a string, use primary_tag().
\& Args    : on set, Bio::Annotation::OntologyTerm object.
\&           NB: to set a string (SOFA name or identifier), use primary_tag()
.Ve
.SS "\fIsource()\fP"
.IX Subsection "source()"
.Vb 6
\& Usage   : $obj\->source($newval)
\& Function: holds the source of the feature.
\& Returns : a Bio::Annotation::SimpleValue representing the source.
\&           NB: to get a string, use source_tag()
\& Args    : on set, a Bio::Annotation::SimpleValue object.
\&           NB: to set a string, use source_tag()
.Ve
.SS "\fIscore()\fP"
.IX Subsection "score()"
.Vb 5
\& Usage   : $score = $feat\->score()
\&           $feat\->score($score)
\& Function: holds a value corresponding to the score of the feature.
\& Returns : a string representing the score.
\& Args    : on set, a scalar or a Bio::Annotation::SimpleValue object.
.Ve
.SS "\fIphase()\fP"
.IX Subsection "phase()"
.Vb 6
\& Usage   : $phase = $feat\->phase()
\&           $feat\->phase($phase)
\& Function: get/set on phase information
\& Returns : a string 0,1,2,\*(Aq.\*(Aq
\& Args    : on set, one of 0,1,2,\*(Aq.\*(Aq or a Bio::Annotation::SimpleValue
\&           object holding one of 0,1,2,\*(Aq.\*(Aq as its value.
.Ve
.SS "\fIframe()\fP"
.IX Subsection "frame()"
.Vb 6
\& Usage   : $frame = $feat\->frame()
\&           $feat\->frame($phase)
\& Function: get/set on phase information
\& Returns : a string 0,1,2,\*(Aq.\*(Aq
\& Args    : on set, one of 0,1,2,\*(Aq.\*(Aq or a Bio::Annotation::SimpleValue
\&           object holding one of 0,1,2,\*(Aq.\*(Aq as its value.
.Ve
.SH "SHORTCUT METHODS TO ACCESS Bio::AnnotatableI INTERFACE METHODS"
.IX Header "SHORTCUT METHODS TO ACCESS Bio::AnnotatableI INTERFACE METHODS"
.SS "\fIadd_Annotation()\fP"
.IX Subsection "add_Annotation()"
.Vb 4
\& Usage   :
\& Function: $obj\->add_Annotation() is a shortcut to $obj\->annotation\->add_Annotation
\& Returns : 
\& Args    :
.Ve
.SS "\fIremove_Annotations()\fP"
.IX Subsection "remove_Annotations()"
.Vb 4
\& Usage   :
\& Function: $obj\->remove_Annotations() is a shortcut to $obj\->annotation\->remove_Annotations
\& Returns : 
\& Args    :
.Ve
.SH "INTERFACE METHODS FOR Bio::SeqFeatureI"
.IX Header "INTERFACE METHODS FOR Bio::SeqFeatureI"
Note that no methods are deprecated.  Any SeqFeatureI methods must return
strings (no objects).
.SS "\fIdisplay_name()\fP"
.IX Subsection "display_name()"
.SS "\fIprimary_tag()\fP"
.IX Subsection "primary_tag()"
.SS "\fIsource_tag()\fP"
.IX Subsection "source_tag()"
.SS "\fIattach_seq()\fP"
.IX Subsection "attach_seq()"
.Vb 6
\& Usage   : $sf\->attach_seq($seq)
\& Function: Attaches a Bio::Seq object to this feature. This
\&           Bio::Seq object is for the *entire* sequence: ie
\&           from 1 to 10000
\& Returns : TRUE on success
\& Args    : a Bio::PrimarySeqI compliant object
.Ve
.SS "\fIseq()\fP"
.IX Subsection "seq()"
.Vb 5
\& Usage   : $tseq = $sf\->seq()
\& Function: returns a truncated version of seq() with bounds matching this feature
\& Returns : sub seq (a Bio::PrimarySeqI compliant object) on attached sequence
\&           bounded by start & end, or undef if there is no sequence attached
\& Args    : none
.Ve
.SS "\fIentire_seq()\fP"
.IX Subsection "entire_seq()"
.Vb 5
\& Usage   : $whole_seq = $sf\->entire_seq()
\& Function: gives the entire sequence that this seqfeature is attached to
\& Returns : a Bio::PrimarySeqI compliant object, or undef if there is no
\&           sequence attached
\& Args    : none
.Ve
.SH "INTERFACE METHODS FOR Bio::RangeI"
.IX Header "INTERFACE METHODS FOR Bio::RangeI"
.Vb 1
\& as inherited via Bio::SeqFeatureI
.Ve
.SS "\fIlength()\fP"
.IX Subsection "length()"
.Vb 4
\& Usage   : $feature\->length()
\& Function: Get the feature length computed as $feat\->end \- $feat\->start + 1
\& Returns : integer
\& Args    : none
.Ve
.SS "\fIstart()\fP"
.IX Subsection "start()"
.Vb 4
\& Usage   : $obj\->start($newval)
\& Function: Get/set on the start coordinate of the feature
\& Returns : integer
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "\fIend()\fP"
.IX Subsection "end()"
.Vb 4
\& Usage   : $obj\->end($newval)
\& Function: Get/set on the end coordinate of the feature
\& Returns : integer
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "\fIstrand()\fP"
.IX Subsection "strand()"
.Vb 4
\& Usage   : $strand = $feat\->strand($newval)
\& Function: get/set on strand information, being 1,\-1 or 0
\& Returns : \-1,1 or 0
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SH "INTERFACE METHODS FOR Bio::FeatureHolderI"
.IX Header "INTERFACE METHODS FOR Bio::FeatureHolderI"
This includes methods for retrieving, adding, and removing
features. Since this is already a feature, features held by this
feature holder are essentially sub-features.
.SS "get_SeqFeatures"
.IX Subsection "get_SeqFeatures"
.Vb 4
\& Usage   : @feats = $feat\->get_SeqFeatures();
\& Function: Returns an array of Bio::SeqFeatureI objects
\& Returns : An array
\& Args    : none
.Ve
.SS "\fIadd_SeqFeature()\fP"
.IX Subsection "add_SeqFeature()"
.Vb 6
\& Usage   : $feat\->add_SeqFeature($subfeat);
\&           $feat\->add_SeqFeature($subfeat,\*(AqEXPAND\*(Aq)
\& Function: adds a SeqFeature into the subSeqFeature array.
\&           with no \*(AqEXPAND\*(Aq qualifer, subfeat will be tested
\&           as to whether it lies inside the parent, and throw
\&           an exception if not.
\&
\&           If EXPAND is used, the parent\*(Aq\*(Aqs start/end/strand will
\&           be adjusted so that it grows to accommodate the new
\&           subFeature
\& Example :
\& Returns : nothing
\& Args    : a Bio::SeqFeatureI object
.Ve
.SS "\fIremove_SeqFeatures()\fP"
.IX Subsection "remove_SeqFeatures()"
.Vb 6
\& Usage   : $obj\->remove_SeqFeatures
\& Function: Removes all sub SeqFeatures.  If you want to remove only a subset,
\&           remove that subset from the returned array, and add back the rest.
\& Returns : The array of Bio::SeqFeatureI implementing sub\-features that was
\&           deleted from this feature.
\& Args    : none
.Ve
.SH "INTERFACE METHODS FOR Bio::AnnotatableI"
.IX Header "INTERFACE METHODS FOR Bio::AnnotatableI"
.SS "\fIannotation()\fP"
.IX Subsection "annotation()"
.Vb 5
\& Usage   : $obj\->annotation($annot_obj)
\& Function: Get/set the annotation collection object for annotating this
\&           feature.
\& Returns : A Bio::AnnotationCollectionI object
\& Args    : newvalue (optional)
.Ve
.SS "\fIlocation()\fP"
.IX Subsection "location()"
.Vb 5
\& Usage   : my $location = $seqfeature\->location()
\& Function: returns a location object suitable for identifying location 
\&           of feature on sequence or parent feature  
\& Returns : Bio::LocationI object
\& Args    : [optional] Bio::LocationI object to set the value to.
.Ve
.SS "\fIadd_target()\fP"
.IX Subsection "add_target()"
.Vb 4
\& Usage   : $seqfeature\->add_target(Bio::LocatableSeq\->new(...));
\& Function: adds a target location on another reference sequence for this feature
\& Returns : true on success
\& Args    : a Bio::LocatableSeq object
.Ve
.SS "\fIeach_target()\fP"
.IX Subsection "each_target()"
.Vb 5
\& Usage   : @targets = $seqfeature\->each_target();
\& Function: Returns a list of Bio::LocatableSeqs which are the locations of this object.
\&           To obtain the "primary" location, see L</location()>.
\& Returns : a list of 0..N Bio::LocatableSeq objects
\& Args    : none
.Ve
.SS "_expand_region"
.IX Subsection "_expand_region"
.Vb 4
\& Title   : _expand_region
\& Usage   : $self\->_expand_region($feature);
\& Function: Expand the total region covered by this feature to
\&           accomodate for the given feature.
\&
\&           May be called whenever any kind of subfeature is added to this
\&           feature. add_SeqFeature() already does this.
\& Returns : 
\& Args    : A Bio::SeqFeatureI implementing object.
.Ve
.SS "get_Annotations"
.IX Subsection "get_Annotations"
.Vb 8
\& Usage   : my $parent   = $obj\->get_Annotations(\*(AqParent\*(Aq);
\&           my @parents = $obj\->get_Annotations(\*(AqParent\*(Aq);
\& Function: a wrapper around Bio::Annotation::Collection::get_Annotations().
\& Returns : returns annotations as
\&           Bio::Annotation::Collection::get_Annotations() does, but
\&           additionally returns a single scalar in scalar context
\&           instead of list context so that if an annotation tag
\&           contains only a single value, you can do:
\&
\&           $parent = $feature\->get_Annotations(\*(AqParent\*(Aq);
\&
\&           instead of:
\&
\&           ($parent) = ($feature\->get_Annotations(\*(AqParent\*(Aq))[0];
\&
\&           if the \*(AqParent\*(Aq tag has multiple values and is called in a
\&           scalar context, the number of annotations is returned.
\&
\& Args    : an annotation tag name.
.Ve
.SH "Bio::SeqFeatureI implemented methods"
.IX Header "Bio::SeqFeatureI implemented methods"
These are specialized implementations of SeqFeatureI methods which call the
internal Bio::Annotation::AnnotationCollection object. Just prior to the 1.5
release the below methods were moved from Bio::SeqFeatureI to Bio::AnnotatableI,
and having Bio::SeqFeatureI inherit Bio::AnnotatableI. This behavior forced all
Bio::SeqFeatureI\-implementing classes to use Bio::AnnotationI objects for any
data. It is the consensus of the core developers that this be rolled back in
favor of a more flexible approach by rolling back the above changes and making
this class Bio::AnnotatableI. The SeqFeatureI tag-related methods are
reimplemented in order to approximate the same behavior as before.
.PP
The methods below allow mapping of the \*(L"\fIget_tag_values()\fR\*(R"\-style annotation
access to Bio::AnnotationCollectionI. These need not be implemented in a
Bio::AnnotationCollectionI compliant class, as they are built on top of the
methods.  For usage, see Bio::SeqFeatureI.
.SS "has_tag"
.IX Subsection "has_tag"
.SS "add_tag_value"
.IX Subsection "add_tag_value"
.SS "get_tag_values"
.IX Subsection "get_tag_values"
.Vb 4
\& Usage   : @annotations = $obj\->get_tag_values($tag)
\& Function: returns annotations corresponding to $tag
\& Returns : a list of scalars
\& Args    : tag name
.Ve
.SS "get_tagset_values"
.IX Subsection "get_tagset_values"
.Vb 6
\& Usage   : @annotations = $obj\->get_tagset_values($tag1,$tag2)
\& Function: returns annotations corresponding to a list of tags.
\&           this is a convenience method equivalent to multiple calls
\&           to get_tag_values with each tag in the list.
\& Returns : a list of Bio::AnnotationI objects.
\& Args    : a list of tag names
.Ve
.SS "get_all_tags"
.IX Subsection "get_all_tags"
.Vb 4
\& Usage   : @tags = $obj\->get_all_tags()
\& Function: returns a list of annotation tag names.
\& Returns : a list of tag names
\& Args    : none
.Ve
.SS "remove_tag"
.IX Subsection "remove_tag"
.Vb 7
\& Usage   : See remove_Annotations().
\& Function:
\& Returns : 
\& Args    : 
\& Note    : Contrary to what the name suggests, this method removes
\&           all annotations corresponding to $tag, not just a
\&           single anntoation.
.Ve
