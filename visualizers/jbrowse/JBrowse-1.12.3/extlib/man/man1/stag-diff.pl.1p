.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "STAG-DIFF 1p"
.TH STAG-DIFF 1p "2009-12-14" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
stag\-diff \- finds the difference between two stag files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  stag\-diff \-ignore foo\-id \-ignore bar\-id file1.xml file2.xml
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Compares two data trees and reports whether they match. If they do not
match, the mismatch is reported.
.IP "\-help|h" 4
.IX Item "-help|h"
shows this document
.IP "\-ignore|i \s-1ELEMENT\s0" 4
.IX Item "-ignore|i ELEMENT"
these nodes are ignored for the purposes of comparison. Note that
attributes are treated as elements, prefixed by the containing element
id. For example, if you have
.Sp
.Vb 1
\&  <foo ID="wibble">
.Ve
.Sp
And you wish to ignore the \s-1ID\s0 attribute, then you would use the switch
.Sp
.Vb 1
\&  \-ignore foo\-ID
.Ve
.Sp
You can specify multiple elements to ignore like this
.Sp
.Vb 1
\&  \-i foo \-i bar \-i baz
.Ve
.Sp
You can also specify paths
.Sp
.Vb 1
\&  \-i foo/bar/bar\-id
.Ve
.IP "\-parser|p \s-1FORMAT\s0" 4
.IX Item "-parser|p FORMAT"
which parser to use. The default is \s-1XML.\s0 This can also be autodetected
by the file suffix. Other alternatives are \fBsxpr\fR and \fBitext\fR. See
Data::Stag for details.
.IP "\-report|r \s-1ELEMENT\s0" 4
.IX Item "-report|r ELEMENT"
report mismatches as they occur on each element of type \s-1ELEMENT\s0
.Sp
multiple elements can be specified
.IP "\-verbose|v" 4
.IX Item "-verbose|v"
used in conjunction with the \fB\-report\fR switch
.Sp
shows the tree of the mismatching element
.SS "\s-1OUTPUT\s0"
.IX Subsection "OUTPUT"
If a mismatch is reported, a report is generated displaying the
subpart of the tree that could not be matched. This will look like
this:
.PP
\&\s-1REASON:\s0
no_matching_node: annotation
  no_matching_node: feature_set
    no_matching_node: feature_span
      no_matching_node: evidence
        no_matching_node: evidence-id
          data_mismatch(:15077290 ne :15077291): evidence-id \s-1AND\s0 evidence-id
.PP
Due to the nature of tree matching, it can be difficult to specify
exactly how trees do not match. To investigate this, you may need to
use the \fB\-r\fR and \fB\-v\fR options. For the above output, I would
recommend using
.PP
.Vb 1
\&  stag\-diff \-r feature_span \-v
.Ve
.SS "\s-1ALGORITHM\s0"
.IX Subsection "ALGORITHM"
Both trees are recursively traversed... see the actual code for how this works
.PP
The order of elements is not important; eg
.PP
.Vb 8
\&  <foo>
\&    <bar>
\&      <baz>1</baz>
\&    </bar>
\&    <bar>
\&      <baz>2</baz>
\&    </bar>
\&  </foo>
.Ve
.PP
matches
.PP
.Vb 8
\&  <foo>
\&    <bar>
\&      <baz>2</baz>
\&    </bar>
\&    <bar>
\&      <baz>1</baz>
\&    </bar>
\&  </foo>
.Ve
.PP
The recursive nature of this algorithm means that certain tree
comparisons will explode wrt time and memory. I think this will only
happen with very deep trees where nodes high up in the tree can only
be differentiated by nodes low down in the tree.
.PP
Both trees are loaded into memory to begin with, so it may thrash with
very large documents
.SS "\s-1AUTHOR\s0"
.IX Subsection "AUTHOR"
Chris Mungall 
cjm at fruitfly dot org
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::Stag
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 189:" 4
.IX Item "Around line 189:"
=over should be: '=over' or '=over positive_number'
