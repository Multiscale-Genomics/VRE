.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Cluster::SequenceFamily 3"
.TH Bio::Cluster::SequenceFamily 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Cluster::SequenceFamily \- Sequence Family object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Bio::SeqIO;
\&  use Bio::Cluster::SequenceFamily;
\&  use File::Spec;
\&
\&  my $file =  File::Spec\->catfile(\*(Aqt\*(Aq,\*(Aqdata\*(Aq,\*(Aqswiss.dat\*(Aq);
\&  my $seqio= Bio::SeqIO\->new(\-format => \*(Aqswiss\*(Aq,
\&                            \-file => $file);
\&  my @mem;
\&  while(my $seq = $seqio\->next_seq){
\&    push @mem, $seq;
\&  }
\&
\&  #create the family
\&  my $family = Bio::Cluster::SequenceFamily\->new(
\&          \-family_id=>"Family_1",
\&          \-description=>"Family Description Here",
\&          \-annotation_score=>"100",
\&          \-members=>\e@mem);
\&
\&  #access the family
\&
\&  foreach my $mem ($family\->get_members){
\&    print $mem\->display_id."\et".$mem\->desc."\en";
\&  }
\&
\&  #select members if members have a Bio::Species Object
\&
\&  my @mem = $family\->get_members(\-binomial=>"Homo sapiens");
\&  @mem = $family\->get_members(\-ncbi_taxid => 9606);
\&  @mem = $family\->get_members(\-common_name=>"Human");
\&  @mem = $family\->get_members(\-species=>"sapiens");
\&  @mem = $family\->get_members(\-genus=>"Homo");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple Family object that may hold any group of object. For more
specific families, one should derive from FamilyI.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
Email bioperl\-l@bioperl.org for support and feedback.
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists. Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and
reponsive experts will be able look at the problem and quickly
address it. Please include a thorough description of the problem
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Shawn Hoon"
.IX Header "AUTHOR - Shawn Hoon"
Email shawnh@fugu\-sg.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a \*(L"_\*(R".
.SS "new"
.IX Subsection "new"
.Vb 8
\& Title   : new
\& Usage   : my $family = Bio::Cluster::SequenceFamily\->new(
\&                             \-family_id=>"Family_1",
\&                             \-description=>"Family Description Here",
\&                             \-annotation_score=>"100",
\&                             \-members=>\e@mem);
\& Function: Constructor for SequenceFamily object
\& Returns : Bio::Cluster::SequenceFamily object
.Ve
.PP
See Bio::Cluster::SequenceFamily.
.SS "version"
.IX Subsection "version"
.Vb 4
\& Title   : version
\& Usage   : $family\->version("1.0");
\& Function: get/set for version
\& Returns : a string version of the family generated.
.Ve
.SS "annotation_score"
.IX Subsection "annotation_score"
.Vb 7
\& Title   : annotation_score
\& Usage   : $family\->annotation_score(100);
\& Function: get/set for annotation_score which
\&           represent the confidence in which the
\&           consensus description has been assigned
\&           to the family.
\& Returns : Bio::SimpleAlign
.Ve
.PP
See Bio::SimpleAlign
.SS "alignment"
.IX Subsection "alignment"
.Vb 5
\& Title   : alignment
\& Usage   : $family\->alignment($align);
\& Function: get/set for an alignment object representing
\&           the multiple alignment of the members of the family.
\& Returns : Bio::SimpleAlign
.Ve
.PP
See Bio::SimpleAlign
.SS "tree"
.IX Subsection "tree"
.Vb 5
\& Title   : tree
\& Usage   : $family\->tree($tree);
\& Function: get/set for an tree object representing
\&           the phylogenetic tree of the family.
\& Returns : Bio::Tree
.Ve
.PP
See Bio::Tree
.SH "Bio::Cluster::FamilyI methods"
.IX Header "Bio::Cluster::FamilyI methods"
.SS "family_score"
.IX Subsection "family_score"
.Vb 4
\& Title   : family_score
\& Usage   : Bio::Cluster::FamilyI\->family_score(95);
\& Function: get/set for the score of algorithm used to generate
\&           the family if present
\&
\&           This is aliased to cluster_score().
\&
\& Returns : the score
\& Args    : the score
.Ve
.SS "family_id"
.IX Subsection "family_id"
.Vb 3
\& Title   : family_id
\& Usage   : $family\->family_id("Family_1");
\& Function: get/set for family id
\&
\&           This is aliased to display_id().
\&
\& Returns : a string specifying identifier of the family
.Ve
.SH "Bio::ClusterI methods"
.IX Header "Bio::ClusterI methods"
.SS "display_id"
.IX Subsection "display_id"
.Vb 5
\& Title   : display_id
\& Usage   :
\& Function: Get/set the display name or identifier for the cluster
\& Returns : a string
\& Args    : optional, on set the display ID ( a string)
.Ve
.SS "description"
.IX Subsection "description"
.Vb 5
\& Title   : description
\& Usage   : $fam\->description("POLYUBIQUITIN")
\& Function: get/set for the consensus description of the cluster
\& Returns : the description string
\& Args    : Optional the description string
.Ve
.SS "get_members"
.IX Subsection "get_members"
.Vb 11
\& Title   : get_members
\& Usage   : Valid criteria:
\&           \-common_name
\&           \-binomial
\&           \-ncbi_taxid
\&           \-organelle
\&           \-genus
\&           $family\->get_members(\-common_name =>"human");
\&           $family\->get_members(\-species     =>"homo sapiens");
\&           $family\->get_members(\-ncbi_taxid  => 9606);
\&           For now, multiple critieria are ORed.
\&
\&           Will return all members if no criteria are provided.
\&
\& Function: get members using methods from L<Bio::Species>
\&           the phylogenetic tree of the family.
\& Returns : an array of objects that are member of this family.
.Ve
.SS "size"
.IX Subsection "size"
.Vb 6
\& Title   : size
\& Usage   : $fam\->size();
\& Function: get/set for the size of the family,
\&           calculated from the number of members
\& Returns : the size of the family
\& Args    :
.Ve
.SS "cluster_score"
.IX Subsection "cluster_score"
.Vb 6
\& Title   : cluster_score
\& Usage   : $fam\->cluster_score(100);
\& Function: get/set for cluster_score which
\&           represent the score in which the clustering
\&           algorithm assigns to this cluster.
\& Returns : a number
.Ve
.SH "Implementation specific methods"
.IX Header "Implementation specific methods"
.Vb 1
\&  These are mostly for adding/removing/changing.
.Ve
.SS "add_members"
.IX Subsection "add_members"
.Vb 5
\& Title   : add_members
\& Usage   : $fam\->add_member([$seq1,$seq1]);
\& Function: add members to a family
\& Returns :
\& Args    : the member(s) to add, as an array or arrayref
.Ve
.SS "remove_members"
.IX Subsection "remove_members"
.Vb 5
\& Title   : remove_members
\& Usage   : $fam\->remove_members();
\& Function: remove all members from a family
\& Returns : the previous array of members
\& Args    : none
.Ve
.SS "members"
.IX Subsection "members"
.Vb 3
\& Title   : members
\& Usage   : $members = $fam\->members([$seq1,$seq1]);
\& Function: Deprecated. Use add_members() or get_members() instead
.Ve
