.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Assembly::Tools::ContigSpectrum 3"
.TH Bio::Assembly::Tools::ContigSpectrum 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Assembly::Tools::ContigSpectrum \- create and manipulate contig spectra
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  # Simple contig spectrum creation
\&  my $csp1 = Bio::Assembly::Tools::ContigSpectrum\->new(
\&    \-id       => \*(Aqcsp1\*(Aq,
\&    \-spectrum => { 1 => 10,
\&                   2 => 2,
\&                   3 => 1 } );
\&
\&  # ...or another way to create a simple contig spectrum
\&  my $csp2 = Bio::Assembly::Tools::ContigSpectrum\->new;
\&  $csp2\->id(\*(Aqcsp2\*(Aq);
\&  $csp2\->spectrum({ 1 => 20, 2 => 1, 4 => 1 });
\&
\&  # Get some information
\&  print "This is contig spectrum ".$csp\->id."\en";
\&  print "It contains ".$csp\->nof_seq." sequences\en";
\&  print "The largest contig has ".$csp\->max_size." sequences\en";
\&  print "The spectrum is: ".$csp\->to_string($csp\->spectrum)."\en";
\&
\&  # Let\*(Aqs add the contig spectra
\&  my $summed_csp = Bio::Assembly::Tools::ContigSpectrum\->new;
\&  $summed_csp\->add($csp1);
\&  $summed_csp\->add($csp2);
\&  print "The summed contig spectrum is ".$summed_csp\->to_string."\en";
\&
\&  # Make an average
\&  my $avg_csp = Bio::Assembly::Tools::ContigSpectrum\->new;
\&  $avg_csp = $avg_csp\->average([$csp1, $csp2]);
\&  print "The average contig spectrum is ".$avg_csp\->to_string."\en";
\&
\&  # Get a contig spectrum from an assembly
\&  my $from_assembly = Bio::Assembly::Tools::ContigSpectrum\->new(
\&    \-assembly       => $assembly_object,
\&    \-eff_asm_params => 1);
\&  print "The contig spectrum from assembly is ".$from_assembly\->to_string."\en";
\&
\&  # Report advanced information (possible because eff_asm_params = 1)
\&  print "Average sequence length: ".$from_assembly\->avg_seq_len." bp\en";
\&  print "Minimum overlap length: ".$from_assembly\->min_overlap." bp\en";
\&  print "Average overlap length: ".$from_assembly\->avg_overlap." bp\en";
\&  print "Minimum overlap match: ".$from_assembly\->min_identity." %\en";
\&  print "Average overlap match: ".$from_assembly\->avg_identity." %\en";
\&
\&  # Assuming the assembly object contains sequences from several different
\&  # metagenomes, we have a mixed contig spectrum from which a cross contig
\&  # spectrum and dissolved contig spectra can be obtained
\&  my $mixed_csp = $from_assembly;
\&
\&  # Calculate a dissolved contig spectrum
\&  my $meta1_dissolved = Bio::Assembly::Tools::ContigSpectrum\->new(
\&    \-dissolve => [$mixed_csp, \*(Aqmetagenome1\*(Aq] );
\&  my $meta2_dissolved = Bio::Assembly::Tools::ContigSpectrum\->new(
\&    \-dissolve => [$mixed_csp, \*(Aqmetagenome2\*(Aq] );
\&  print "The dissolved contig spectra are:\en".
\&    $meta1_dissolved\->to_string."\en".
\&    $meta2_dissolved\->to_string."\en";
\&
\&  # Determine a cross contig spectrum
\&  my $cross_csp = Bio::Assembly::Tools::ContigSpectrum\->new(
\&    \-cross => $mixed_csp );
\&  print "The cross contig spectrum is ".$cross_csp\->to_string."\en";
\&
\&  # Score a contig spectrum (the more abundant the contigs and the larger their
\&  # size, the larger the score)
\&  my $csp_score = $csp\->score( $csp\->nof_seq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Bio::Assembly::Tools::ContigSpectrum Perl module enables to
manually create contig spectra, import them from assemblies,
manipulate them, transform between different types of contig spectra
and output them.
.PP
Bio::Assembly::Tools::ContigSpectrum is a module to create, manipulate
and output contig spectra, assembly-derived data used in metagenomics
(community genomics) for diversity estimation.
.SS "Background"
.IX Subsection "Background"
A contig spectrum is the count of the number of contigs of different
size in an assembly. For example, the contig spectrum [100 5 1 0 0
\&...] means that there were 100 singlets (1\-contigs), 5 contigs of 2
sequences (2\-contigs), 1 contig of 3 sequences (3\-contig) and no
larger contigs.
.PP
An assembly can be produced from a mixture of sequences from different
metagenomes. The contig obtained from this assembly is a mixed contig
spectrum. The contribution of each metagenome in this mixed contig
spectrum can be obtained by determining a dissolved contig spectrum.
.PP
Finally, based on a mixed contig spectrum, a cross contig spectrum can
be determined. In a cross contig spectrum, only contigs containing
sequences from different metagenomes are kept; \*(L"pure\*(R" contigs are
excluded. Additionally, the total number of singletons (1\-contigs)
from each region that assembles with any fragments from other regions
is the number of 1\-contigs in the cross contig spectrum.
.SS "Implementation"
.IX Subsection "Implementation"
The simplest representation of a contig spectrum is as a hash
representation where the key is the contig size (number of sequences
making up the contig) and the value the number of contigs of this
size.
.PP
In fact, it is useful to have more information associated with the
contig spectrum, hence the Bio::Assembly::Tools::ContigSpectrum module
implements an object containing a contig spectrum hash and additional
information. The get/set methods to access them are:
.PP
.Vb 4
\&    id              contig spectrum ID
\&    nof_rep         number of repetitions (assemblies) used
\&    max_size        size of (number of sequences in) the largest contig
\&    spectrum        hash representation of a contig spectrum
\&
\&    nof_seq         number of sequences
\&    avg_seq_len     average sequence length
\&
\&    eff_asm_params  reports effective assembly parameters
\&
\&    nof_overlaps    number of overlaps (needs eff_asm_params)
\&    min_overlap     minimum overlap length in a contig (needs eff_asm_params)
\&    min_identity    minimum sequence identity percentage (needs eff_asm_params)
\&    avg_overlap     average overlap length (needs eff_asm_params)
\&    avg_identity    average overlap identity percentage (needs eff_asm_params)
\&
\&  Operations on the contig spectra:
\&
\&    to_string       create a string representation of the spectrum
\&    spectrum        import a hash contig spectrum
\&    assembly        determine a contig spectrum from an assembly, contig or singlet
\&    dissolve        calculate a dissolved contig spectrum (depends on assembly)
\&    cross           produce a cross contig spectrum (depends on assembly)
\&    add             add a contig spectrum to an existing one
\&    average         make an average of several contig spectra
\&    score           score a contig spectrum: the higher the number of contigs
\&                      and the larger their size, the higher the score.
.Ve
.PP
When using operations that rely on knowing \*(L"where\*(R" (from what
metagenomes) a sequence came from (i.e. when creating a dissolved or
cross contig spectrum), make sure that the sequences used for the
assembly have a name header, e.g.  >metagenome1|seq1,
>metagenome2|seq1, ...
.PP
Note: The following operations require the \f(CW\*(C`Graph::Undirected\*(C'\fR module:
   eff_asm_params, cross, dissolve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to the
Bioperl mailing lists  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the BioPerl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via email
or the web:
.PP
.Vb 2
\&  bioperl\-bugs@bio.perl.org
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Florent E Angly"
.IX Header "AUTHOR - Florent E Angly"
Email florent_dot_angly_at_gmail_dot_com
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a \*(L"_\*(R".
.SS "new"
.IX Subsection "new"
.Vb 10
\&  Title   : new
\&  Usage   : my $csp = Bio::Assembly::Tools::ContigSpectrum\->new();
\&              or
\&            my $csp = Bio::Assembly::Tools::ContigSpectrum\->new(
\&              \-id => \*(Aqsome_name\*(Aq,
\&              \-spectrum =>  { 1 => 90 , 2 => 3 , 4 => 1 },
\&            );
\&              or
\&            my $csp = Bio::Assembly::Tools::ContigSpectrum\->new(
\&              \-assembly =>  $assembly_obj
\&            );
\&  Function: create a new contig spectrum object
\&  Returns : reference to a contig spectrum object
\&  Args    : none
.Ve
.SS "id"
.IX Subsection "id"
.Vb 5
\&  Title   : id
\&  Usage   : $csp\->id
\&  Function: get/set contig spectrum id
\&  Returns : string
\&  Args    : string [optional]
.Ve
.SS "nof_seq"
.IX Subsection "nof_seq"
.Vb 5
\&  Title   : nof_seq
\&  Usage   : $csp\->nof_seq
\&  Function: get/set the number of sequences making up the contig spectrum
\&  Returns : integer
\&  Args    : integer [optional]
.Ve
.SS "nof_rep"
.IX Subsection "nof_rep"
.Vb 6
\&  Title   : nof_rep
\&  Usage   : $csp\->nof_rep
\&  Function: Get/Set the number of repetitions (assemblies) used to create the 
\&            contig spectrum
\&  Returns : integer
\&  Args    : integer [optional]
.Ve
.SS "max_size"
.IX Subsection "max_size"
.Vb 5
\&  Title   : max_size
\&  Usage   : $csp\->max_size
\&  Function: get/set the size of (number of sequences in) the largest contig
\&  Returns : integer
\&  Args    : integer [optional]
.Ve
.SS "nof_overlaps"
.IX Subsection "nof_overlaps"
.Vb 5
\&  Title   : nof_overlaps
\&  Usage   : $csp\->nof_overlaps
\&  Function: Get/Set the number of overlaps in the assembly.
\&  Returns : integer
\&  Args    : integer [optional]
.Ve
.SS "min_overlap"
.IX Subsection "min_overlap"
.Vb 5
\&  Title   : min_overlap
\&  Usage   : $csp\->min_overlap
\&  Function: get/set the assembly minimum overlap length
\&  Returns : integer
\&  Args    : integer [optional]
.Ve
.SS "avg_overlap"
.IX Subsection "avg_overlap"
.Vb 5
\&  Title   : avg_overlap
\&  Usage   : $csp\->avg_overlap
\&  Function: get/set the assembly average overlap length
\&  Returns : decimal
\&  Args    : decimal [optional]
.Ve
.SS "min_identity"
.IX Subsection "min_identity"
.Vb 5
\&  Title   : min_identity
\&  Usage   : $csp\->min_identity
\&  Function: get/set the assembly minimum overlap identity percent
\&  Returns : 0 < decimal < 100
\&  Args    : 0 < decimal < 100 [optional]
.Ve
.SS "avg_identity"
.IX Subsection "avg_identity"
.Vb 5
\&  Title   : avg_identity
\&  Usage   : $csp\->avg_identity
\&  Function: get/set the assembly average overlap identity percent
\&  Returns : 0 < decimal < 100
\&  Args    : 0 < decimal < 100 [optional]
.Ve
.SS "avg_seq_len"
.IX Subsection "avg_seq_len"
.Vb 5
\&  Title   : avg_seq_len
\&  Usage   : $csp\->avg_seq_len
\&  Function: get/set the assembly average sequence length
\&  Returns : avg_seq_len
\&  Args    : real [optional]
.Ve
.SS "eff_asm_params"
.IX Subsection "eff_asm_params"
.Vb 10
\&  Title   : eff_asm_params
\&  Usage   : $csp\->eff_asm_params(1)
\&  Function: Get/set the effective assembly parameters option. It defines if the
\&            effective assembly parameters should be determined when a contig
\&            spectrum based or derived from an assembly is calculated. The
\&            effective assembly parameters include avg_seq_length, nof_overlaps,
\&            min_overlap, avg_overlap, min_identity and avg_identity.
\&            1 = get them, 0 = don\*(Aqt.
\&  Returns : integer
\&  Args    : integer [optional]
.Ve
.SS "spectrum"
.IX Subsection "spectrum"
.Vb 10
\&  Title   : spectrum
\&  Usage   : my $spectrum = $csp\->spectrum({1=>10, 2=>2, 3=>1});
\&  Function: Get the current contig spectrum represented as a hash / Update a
\&            contig spectrum object based on a contig spectrum represented as a
\&            hash
\&            The hash representation of a contig spectrum is as following:
\&              key   \-> contig size (in number of sequences)
\&              value \-> number of contigs of this size
\&  Returns : contig spectrum as a hash reference
\&  Args    : contig spectrum as a hash reference [optional]
.Ve
.SS "assembly"
.IX Subsection "assembly"
.Vb 8
\&  Title   : assembly
\&  Usage   : my @obj_list = $csp\->assembly();
\&  Function: get/set the contig spectrum object by adding an assembly, contig or
\&            singlet object to it, or get the list of objects associated with it
\&  Returns : arrayref of assembly, contig and singlet objects used in the contig
\&            spectrum object (Bio::Assembly::Scaffold, Bio::Assembly::Contig and
\&            Bio::Assembly::Singlet objects)
\&  Args    : Bio::Assembly::Scaffold, Contig or Singlet object
.Ve
.SS "drop_assembly"
.IX Subsection "drop_assembly"
.Vb 9
\&  Title   : drop_assembly
\&  Usage   : $csp\->drop_assembly();
\&  Function: Remove all assembly objects associated with a contig spectrum.
\&            Assembly objects can take a lot of memory, which can be freed by
\&            calling this method. Don\*(Aqt call this method if you need the assembly
\&            object later on, for example for creating a dissolved or cross
\&            contig spectrum.
\&  Returns : 1 for success
\&  Args    : none
.Ve
.SS "dissolve"
.IX Subsection "dissolve"
.Vb 10
\&  Title   : dissolve
\&  Usage   : $dissolved_csp\->dissolve($mixed_csp, $seq_header);
\&  Function: Dissolve a mixed contig spectrum for the set of sequences that
\&            contain the specified header, i.e. determine the contribution of
\&            these sequences to the mixed contig spectrum. The mixed contig
\&            spectrum object must have one or several assembly object(s). In
\&            addition, min_overlap, min_identity and eff_asm_params are taken
\&            from the mixed contig spectrum, unless they are specified manually
\&            for the dissolved contig spectrum. The dissolved contigs underlying
\&            the contig spectrum can be obtained by calling the assembly() method.
\&  Returns : 1 for success
\&  Args    : Bio::Assembly::Tools::ContigSpectrum reference
\&            sequence header string
.Ve
.SS "cross"
.IX Subsection "cross"
.Vb 7
\&  Title   : cross
\&  Usage   : $cross_csp\->cross($mixed_csp);
\&  Function: Calculate a cross contig_spectrum based on a mixed contig_spectrum.
\&            The underlying cross\-contigs themselves can be obtained by calling 
\&            the assembly() method.
\&  Returns : 1 for success
\&  Args    : Bio::Assembly::Tools::ContigSpectrum reference
.Ve
.SS "to_string"
.IX Subsection "to_string"
.Vb 8
\&  Title   : to_string
\&  Usage   : my $csp_string = $csp\->to_string;
\&  Function: Convert the contig spectrum into a string (easy to print!!).
\&  Returns : string
\&  Args    : element separator (integer) [optional]
\&              1 \-> space\-separated
\&              2 \-> tab\-separated
\&              3 \-> newline\-separated
.Ve
.SS "add"
.IX Subsection "add"
.Vb 6
\&  Title   : add
\&  Usage   : $csp\->add($additional_csp);
\&  Function: Add a contig spectrum to an existing one: sums the spectra, update
\&            the number of sequences, number of repetitions, ...
\&  Returns : 1 for success
\&  Args    : Bio::Assembly::Tools::ContigSpectrum object
.Ve
.SS "average"
.IX Subsection "average"
.Vb 7
\&  Title   : average
\&  Usage   : my $avg_csp = $csp\->average([$csp1, $csp2, $csp3]);
\&  Function: Average one contig spectrum or the sum of several contig spectra by
\&            the number of repetitions
\&  Returns : Bio::Assembly::Tools::ContigSpectrum
\&  Args    : Bio::Assembly::Tools::ContigSpectrum array reference
\&            eff_asm_params
.Ve
.SS "score"
.IX Subsection "score"
.Vb 10
\&  Title   : score
\&  Usage   : my $score = $csp\->score();
\&  Function: Score a contig spectrum (or cross\-contig spectrum) such that the
\&             higher the number of contigs (or cross\-contigs) and the larger their 
\&             size, the higher the score.
\&             Let n   : total number of sequences
\&                 c_q : number of contigs of size q
\&                 q   : number of sequence in a contig
\&             We define: score = n/(n\-1) * (X \- 1/n)
\&                  where X = sum ( c_q * q^2 ) / n**2
\&             The score ranges from 0 (singlets only) to 1 (a single large contig)
\&             It is possible to specify a value for the number of sequences to
\&              assume in the contig spectrum.
\&  Returns : contig score, or undef if there were no sequences in the contig spectrum
\&  Args    : number of total sequences to assume [optional]
.Ve
.SS "_naive_assembler"
.IX Subsection "_naive_assembler"
.Vb 11
\&  Title   : _naive_assembler
\&  Usage   : 
\&  Function: Reassemble the specified sequences only based on their position in
\&            the contig. This naive assembly only verifies that the minimum
\&            overlap length and percentage identity are respected. No actual
\&            alignment is done
\&  Returns : arrayref of contigs and singlets
\&  Args    : Bio::Assembly::Contig
\&            array reference of sequence IDs to use [optional]
\&            minimum overlap length (integer)       [optional]
\&            minimum percentage identity (integer)  [optional]
.Ve
.SS "_create_subcontig"
.IX Subsection "_create_subcontig"
.Vb 7
\&  Title   : _create_subcontig
\&  Usage   : 
\&  Function: Create a subcontig from another contig
\&  Returns : Bio::Assembly::Contig object
\&  Args    : Bio::Assembly::Contig
\&            arrayref of the IDs of the reads to includes in the subcontig
\&            ID to give to the subcontig
.Ve
.SS "_obj_copy"
.IX Subsection "_obj_copy"
.Vb 9
\&  Title   : _obj_copy
\&  Usage   : 
\&  Function: Copy (most of) an object, and optionally truncate it
\&  Returns : another a Bio::LocatableSeq, Bio::Seq::PrimaryQual, or
\&              Bio::SeqFeature::Generic object
\&  Args    : a Bio::LocatableSeq, Bio::Seq::PrimaryQual, or
\&              Bio::SeqFeature::Generic object
\&            a start position
\&            an end position
.Ve
.SS "_new_from_assembly"
.IX Subsection "_new_from_assembly"
.Vb 6
\&  Title   : _new_from_assembly
\&  Usage   : 
\&  Function: Creates a new contig spectrum object based solely on the result of 
\&            an assembly, contig or singlet
\&  Returns : Bio::Assembly::Tools::ContigSpectrum object
\&  Args    : Bio::Assembly::Scaffold, Contig or Singlet object
.Ve
.SS "_new_dissolved_csp"
.IX Subsection "_new_dissolved_csp"
.Vb 6
\&  Title   : _new_dissolved_csp
\&  Usage   : 
\&  Function: create a dissolved contig spectrum object
\&  Returns : dissolved contig spectrum
\&  Args    : mixed contig spectrum
\&            header of sequences to keep in this contig spectrum
.Ve
.SS "_dissolve_contig"
.IX Subsection "_dissolve_contig"
.Vb 8
\&  Title   : _dissolve_contig
\&  Usage   : 
\&  Function: dissolve a contig
\&  Returns : arrayref of contigs and singlets
\&  Args    : mixed contig spectrum
\&            header of sequences to keep in this contig spectrum
\&            minimum overlap
\&            minimum identity
.Ve
.SS "_new_cross_csp"
.IX Subsection "_new_cross_csp"
.Vb 5
\&  Title   : _new_cross_csp
\&  Usage   : 
\&  Function: create a cross contig spectrum object
\&  Returns : cross\-contig spectrum
\&  Args    : mixed contig spectrum
.Ve
.SS "_cross_contig"
.IX Subsection "_cross_contig"
.Vb 8
\&  Title   : _cross_contig
\&  Usage   : 
\&  Function: calculate cross contigs
\&  Returns : arrayref of cross\-contigs
\&            number of cross\-singlets
\&  Args    : contig
\&            minimum overlap
\&            minimum identity
.Ve
.SS "_seq_origin"
.IX Subsection "_seq_origin"
.Vb 7
\&  Title   : _seq_origin
\&  Usage   : 
\&  Function: determines where a sequence comes from using its header. For example
\&            the origin of the sequence \*(Aqmetagenome1|gi|9626988|ref|NC_001508.1|\*(Aq
\&            is \*(Aqmetagenome1\*(Aq
\&  Returns : origin
\&  Args    : sequence ID
.Ve
.SS "_import_assembly"
.IX Subsection "_import_assembly"
.Vb 6
\&  Title   : _import_assembly
\&  Usage   : $csp\->_import_assembly($assemblyobj);
\&  Function: Update a contig spectrum object based on an assembly, contig or
\&            singlet object
\&  Returns : 1 for success
\&  Args    : Bio::Assembly::Scaffold, Contig or Singlet object
.Ve
.SS "_import_spectrum"
.IX Subsection "_import_spectrum"
.Vb 7
\&  Title   : _import_spectrum
\&  Usage   : $csp\->_import_spectrum({ 1 => 90 , 2 => 3 , 4 => 1 })
\&  Function: update a contig spectrum object based on a contig spectrum
\&            represented as a hash (key: contig size, value: number of contigs of
\&            this size)
\&  Returns : 1 for success
\&  Args    : contig spectrum as a hash reference
.Ve
.SS "_import_dissolved_csp"
.IX Subsection "_import_dissolved_csp"
.Vb 7
\&  Title   : _import_dissolved_csp
\&  Usage   : $csp\->_import_dissolved_csp($mixed_csp, $seq_header);
\&  Function: Update a contig spectrum object by dissolving a mixed contig
\&            spectrum based on the header of the sequences
\&  Returns : 1 for success
\&  Args    : Bio::Assembly::Tools::ContigSpectrum
\&            sequence header string
.Ve
.SS "_import_cross_csp"
.IX Subsection "_import_cross_csp"
.Vb 6
\&  Title   : _import_cross_csp
\&  Usage   : $csp\->_import_cross_csp($mixed_csp);
\&  Function: Update a contig spectrum object by calculating the cross contig
\&            spectrum based on a mixed contig spectrum
\&  Returns : 1 for success
\&  Args    : Bio::Assembly::Tools::ContigSpectrum
.Ve
.SS "_get_contig_like"
.IX Subsection "_get_contig_like"
.Vb 5
\&  Title   : _get_contig_like
\&  Usage   : my @contig_like_objs = $csp\->_get_contig_like($assembly_obj);
\&  Function: Get contigs and singlets from an assembly, contig or singlet
\&  Returns : array of Bio::Assembly::Contig and Singlet objects
\&  Args    : a Bio::Assembly::Scaffold, Contig or singlet object
.Ve
.SS "_get_assembly_seq_stats"
.IX Subsection "_get_assembly_seq_stats"
.Vb 8
\&  Title   : _get_assembly_seq_stats
\&  Usage   : my $seqlength = $csp\->_get_assembly_seq_stats($assemblyobj);
\&  Function: Get sequence statistics from an assembly:
\&              average sequence length, number of sequences
\&  Returns : average sequence length (decimal)
\&            number of sequences (integer)
\&  Args    : Bio::Assembly::Scaffold, Contig or singlet object
\&            hash reference with the IDs of the sequences to consider [optional]
.Ve
.SS "_get_contig_seq_stats"
.IX Subsection "_get_contig_seq_stats"
.Vb 8
\&  Title   : _get_contig_seq_stats
\&  Usage   : my $seqlength = $csp\->_get_contig_seq_stats($contigobj);
\&  Function: Get sequence statistics from a contig:
\&              average sequence length, number of sequences
\&  Returns : average sequence length (decimal)
\&            number of sequences (integer)
\&  Args    : contig object reference
\&            hash reference with the IDs of the sequences to consider [optional]
.Ve
.SS "_update_seq_stats"
.IX Subsection "_update_seq_stats"
.Vb 10
\&  Title   : _update_seq_stats
\&  Usage   : 
\&  Function: Update the number of sequences and their average length 1
\&            average identity 1
\&            minimum length 1
\&            minimum identity 1
\&            number of overlaps 1 average sequence length
\&  Returns : average sequence length
\&            number of sequences
\&  Args    : average sequence length 1
\&            number of sequences 1
\&            average sequence length 2
\&            number of sequences 2
.Ve
.SS "_get_assembly_overlap_stats"
.IX Subsection "_get_assembly_overlap_stats"
.Vb 11
\&  Title   : _get_assembly_overlap_stats
\&  Usage   : my ($avglength, $avgidentity, $minlength, $min_identity, $nof_overlaps)
\&              = $csp\->_get_assembly_overlap_stats($assemblyobj);
\&  Function: Get statistics about pairwise overlaps in contigs of an assembly
\&  Returns : average overlap length
\&            average identity percent
\&            minimum overlap length
\&            minimum identity percent
\&            number of overlaps
\&  Args    : Bio::Assembly::Scaffold, Contig or Singlet object
\&            hash reference with the IDs of the sequences to consider [optional]
.Ve
.SS "_get_contig_overlap_stats"
.IX Subsection "_get_contig_overlap_stats"
.Vb 10
\&  Title   : _get_contig_overlap_stats
\&  Usage   : my ($avglength, $avgidentity, $minlength, $min_identity, $nof_overlaps)
\&              = $csp\->_get_contig_overlap_stats($contigobj);
\&  Function: Get statistics about pairwise overlaps in a contig or singlet. The
\&              statistics are obtained using graph theory: each read is a node
\&              and the edges between 2 reads are weighted by minus the number of
\&              conserved residues in the alignment between the 2 reads. The
\&              minimum spanning tree of this graph represents the overlaps that
\&              form the contig. Overlaps that do not satisfy the minimum overlap
\&              length and similarity get a malus on their score.
\&              Note: This function requires the optional BioPerl dependency
\&              module called \*(AqGraph\*(Aq
\&  Returns : average overlap length
\&            average identity percent
\&            minimum overlap length
\&            minimum identity percent
\&            number of overlaps
\&  Args    : Bio::Assembly::Contig or Singlet object
\&            hash reference with the IDs of the sequences to consider [optional]
.Ve
.SS "_update_overlap_stats"
.IX Subsection "_update_overlap_stats"
.Vb 10
\&  Title   : _update_overlap_stats
\&  Usage   : 
\&  Function: update the number of overlaps and their minimum and average length
\&            and identity
\&  Returns : 
\&  Args    : average length 1
\&            average identity 1
\&            minimum length 1
\&            minimum identity 1
\&            number of overlaps 1
\&            average length 2
\&            average identity 2
\&            minimum length 2
\&            minimum identity 2
\&            number of overlaps 2
.Ve
.SS "_overlap_alignment"
.IX Subsection "_overlap_alignment"
.Vb 10
\&  Title   : _overlap_alignment
\&  Usage   : 
\&  Function: Produce an alignment of the overlapping section of two sequences of
\&            a contig. Minimum overlap length and percentage identity can be
\&            specified. Return undef if the sequences do not overlap or do not
\&            meet the minimum overlap criteria.
\&  Return  : Bio::SimpleAlign object reference
\&            alignment overlap length
\&            alignment overlap identity
\&  Args    : Bio::Assembly::Contig object reference
\&            Bio::LocatableSeq contig sequence 1
\&            Bio::LocatableSeq contig sequence 2
\&            minimum overlap length [optional]
\&            minimum overlap identity percentage[optional]
.Ve
.SS "_contig_graph"
.IX Subsection "_contig_graph"
.Vb 10
\&  Title   : _contig_graph
\&  Usage   : 
\&  Function: Creates a graph data structure of the contig.The graph is undirected.
\&            The vertices are the reads of the contig and edges are the overlap
\&            between the reads. The edges are weighted by the opposite of the
\&            overlap, so it is negative and the better the overlap, the lower the
\&            weight.
\&  Return  : Graph object or undef
\&            hashref of overlaps (score, length, identity) for each read pair
\&  Args    : Bio::Assembly::Contig object reference
\&            hash reference with the IDs of the sequences to consider [optional]
\&            minimum overlap length (integer)                         [optional]
\&            minimum percentage identity (integer)                    [optional]
.Ve
.SS "_draw_graph"
.IX Subsection "_draw_graph"
.Vb 9
\&  Title   : _draw_graph
\&  Usage   : 
\&  Function: Generates a PNG picture of the contig graph. It is mostly for
\&            debugging purposes.
\&  Return  : 1 for success
\&  Args    : a Graph object
\&            hashref of overlaps (score, length, identity) for each read pair
\&            name of output file
\&            overlap info to display: \*(Aqscore\*(Aq (default), \*(Aqlength\*(Aq or \*(Aqidentity\*(Aq
.Ve
