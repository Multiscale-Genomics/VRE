.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::GFF::Segment 3"
.TH Bio::DB::GFF::Segment 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::GFF::Segment \-\- Simple DNA segment object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Bio::DB::GFF.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::DB::GFF::Segment provides the basic representation of a range of
\&\s-1DNA\s0 contained in a \s-1GFF\s0 database.  It is the base class from which the
Bio::DB::GFF::RelSegment and Bio::DB::GFF::Feature classes are
derived.
.PP
Generally, you will not create or manipulate Bio::DB::GFF::Segment
objects directly, but use those that are returned by the Bio::DB::GFF
module.
.SH "API"
.IX Header "API"
The remainder of this document describes the \s-1API\s0 for
Bio::DB::GFF::Segment.
.SS "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : $s = Bio::DB::GFF::Segment\->new(@args)
\& Function: create a new segment
\& Returns : a new Bio::DB::GFF::Segment object
\& Args    : see below
\& Status  : Public
.Ve
.PP
This method creates a new Bio::DB::GFF::Segment object.  Generally
this is called automatically by the Bio::DB::GFF module and
derivatives.
.PP
There are five positional arguments:
.PP
.Vb 5
\& $factory      a Bio::DB::GFF::Adaptor to use for database access
\& $sourceseq    ID of the source sequence
\& $sourceclass  class of the source sequence
\& $start        start of the desired segment relative to source sequence
\& $stop         stop of the desired segment relative to source sequence
.Ve
.SS "factory"
.IX Subsection "factory"
.Vb 6
\& Title   : factory
\& Usage   : $s\->factory
\& Function: get the factory object
\& Returns : a Bio::DB::GFF::Adaptor
\& Args    : none
\& Status  : Public
.Ve
.PP
This is a read-only accessor for the Bio::DB::GFF::Adaptor object used 
to create the segment.
.SS "start"
.IX Subsection "start"
.Vb 6
\& Title   : start
\& Usage   : $s\->start
\& Function: start of segment
\& Returns : integer
\& Args    : none
\& Status  : Public
.Ve
.PP
This is a read-only accessor for the start of the segment.
.SS "end"
.IX Subsection "end"
.Vb 6
\& Title   : end
\& Usage   : $s\->end
\& Function: end of segment
\& Returns : integer
\& Args    : none
\& Status  : Public
.Ve
.PP
This is a read-only accessor for the end of the segment.
.SS "stop"
.IX Subsection "stop"
.Vb 6
\& Title   : stop
\& Usage   : $s\->stop
\& Function: stop of segment
\& Returns : integer
\& Args    : none
\& Status  : Public
.Ve
.PP
This is an alias for \fIend()\fR, provided for AcePerl compatibility.
.SS "length"
.IX Subsection "length"
.Vb 6
\& Title   : length
\& Usage   : $s\->length
\& Function: length of segment
\& Returns : integer
\& Args    : none
\& Status  : Public
.Ve
.PP
Returns the length of the segment.  Always a positive number.
.SS "strand"
.IX Subsection "strand"
.Vb 6
\& Title   : strand
\& Usage   : $s\->strand
\& Function: strand of segment
\& Returns : +1,0,\-1
\& Args    : none
\& Status  : Public
.Ve
.PP
Returns the strand on which the segment resides, either +1, 0 or \-1.
.SS "low"
.IX Subsection "low"
.Vb 6
\& Title   : low
\& Usage   : $s\->low
\& Function: return lower coordinate
\& Returns : lower coordinate
\& Args    : none
\& Status  : Public
.Ve
.PP
Returns the lower coordinate, either start or end.
.SS "high"
.IX Subsection "high"
.Vb 6
\& Title   : high
\& Usage   : $s\->high
\& Function: return higher coordinate
\& Returns : higher coordinate
\& Args    : none
\& Status  : Public
.Ve
.PP
Returns the higher coordinate, either start or end.
.SS "sourceseq"
.IX Subsection "sourceseq"
.Vb 6
\& Title   : sourceseq
\& Usage   : $s\->sourceseq
\& Function: get the segment source
\& Returns : a string
\& Args    : none
\& Status  : Public
.Ve
.PP
Returns the name of the source sequence for this segment.
.SS "class"
.IX Subsection "class"
.Vb 6
\& Title   : class
\& Usage   : $s\->class([$newclass])
\& Function: get the source sequence class
\& Returns : a string
\& Args    : new class (optional)
\& Status  : Public
.Ve
.PP
Gets or sets the class for the source sequence for this segment.
.SS "subseq"
.IX Subsection "subseq"
.Vb 6
\& Title   : subseq
\& Usage   : $s\->subseq($start,$stop)
\& Function: generate a subsequence
\& Returns : a Bio::DB::GFF::Segment object
\& Args    : start and end of subsequence
\& Status  : Public
.Ve
.PP
This method generates a new segment from the start and end positions
given in the arguments.  If stop < start, then the strand is reversed.
.SS "seq"
.IX Subsection "seq"
.Vb 6
\& Title   : seq
\& Usage   : $s\->seq
\& Function: get the sequence string for this segment
\& Returns : a Bio::PrimarySeq
\& Args    : none
\& Status  : Public
.Ve
.PP
Returns the sequence for this segment as a Bio::PrimarySeq.  (\-)
strand segments are automatically reverse complemented
.PP
The method is called \fIdna()\fR return the data as a simple sequence
string.
.SS "dna"
.IX Subsection "dna"
.Vb 6
\& Title   : dna
\& Usage   : $s\->dna
\& Function: get the DNA string for this segment
\& Returns : a string
\& Args    : none
\& Status  : Public
.Ve
.PP
Returns the sequence for this segment as a simple string. (\-) strand
segments are automatically reverse complemented
.PP
The method is also called \fIprotein()\fR.
.SS "primary_seq"
.IX Subsection "primary_seq"
.Vb 6
\& Title   : primary_seq
\& Usage   : $s\->primary_seq
\& Function: returns a Bio::PrimarySeqI compatible object
\& Returns : a Bio::PrimarySeqI object
\& Args    : none
\& Status  : Public
.Ve
.PP
This is for compatibility with BioPerl's separation of SeqI
from PrimarySeqI.  It just returns itself.
.SS "type"
.IX Subsection "type"
.Vb 6
\& Title   : type
\& Usage   : $s\->type
\& Function: return the string "feature"
\& Returns : the string "feature"
\& Args    : none
\& Status  : Public
.Ve
.PP
This is for future sequence ontology-compatibility and
represents the default type of a feature on the genome
.SS "equals"
.IX Subsection "equals"
.Vb 6
\& Title   : equals
\& Usage   : $s\->equals($d)
\& Function: segment equality
\& Returns : true, if two segments are equal
\& Args    : another segment
\& Status  : Public
.Ve
.PP
Returns true if the two segments have the same source sequence, start and stop.
.SS "asString"
.IX Subsection "asString"
.Vb 6
\& Title   : asString
\& Usage   : $s\->asString
\& Function: human\-readable string for segment
\& Returns : a string
\& Args    : none
\& Status  : Public
.Ve
.PP
Returns a human-readable string representing this sequence.  Format
is:
.PP
.Vb 1
\&   sourceseq/start,stop
.Ve
.SS "clone"
.IX Subsection "clone"
.Vb 6
\& Title   : clone
\& Usage   : $copy = $s\->clone
\& Function: make a copy of this segment
\& Returns : a Bio::DB::GFF::Segment object
\& Args    : none
\& Status  : Public
.Ve
.PP
This method creates a copy of the segment and returns it.
.SS "error"
.IX Subsection "error"
.Vb 6
\& Title   : error
\& Usage   : $error = $s\->error([$new_error])
\& Function: get or set the last error
\& Returns : a string
\& Args    : an error message (optional)
\& Status  : Public
.Ve
.PP
In case of a fault, this method can be used to obtain the last error
message.  Internally it is called to set the error message.
.SH "Relative Addressing Methods"
.IX Header "Relative Addressing Methods"
The following methods are provided for compatibility with
Bio::DB::GFF::RelSegment, which provides relative addressing
functions.
.SS "abs_start"
.IX Subsection "abs_start"
.Vb 6
\& Title   : abs_start
\& Usage   : $s\->abs_start
\& Function: the absolute start of the segment
\& Returns : an integer
\& Args    : none
\& Status  : Public
.Ve
.PP
This is an alias to \fIstart()\fR, and provided for \s-1API\s0 compatibility with
Bio::DB::GFF::RelSegment.
.SS "abs_end"
.IX Subsection "abs_end"
.Vb 6
\& Title   : abs_end
\& Usage   : $s\->abs_end
\& Function: the absolute stop of the segment
\& Returns : an integer
\& Args    : none
\& Status  : Public
.Ve
.PP
This is an alias to \fIstop()\fR, and provided for \s-1API\s0 compatibility with
Bio::DB::GFF::RelSegment.
.SS "abs_strand"
.IX Subsection "abs_strand"
.Vb 6
\& Title   : abs_strand
\& Usage   : $s\->abs_strand
\& Function: the absolute strand of the segment
\& Returns : +1,0,\-1
\& Args    : none
\& Status  : Public
.Ve
.PP
This is an alias to \fIstrand()\fR, and provided for \s-1API\s0 compatibility with
Bio::DB::GFF::RelSegment.
.SS "abs_ref"
.IX Subsection "abs_ref"
.Vb 6
\& Title   : abs_ref
\& Usage   : $s\->abs_ref
\& Function: the reference sequence for this segment
\& Returns : a string
\& Args    : none
\& Status  : Public
.Ve
.PP
This is an alias to \fIsourceseq()\fR, and is here to provide \s-1API\s0
compatibility with Bio::DB::GFF::RelSegment.
.SS "refseq"
.IX Subsection "refseq"
.Vb 6
\& Title   : refseq
\& Usage   : $s\->refseq
\& Function: get or set the reference sequence
\& Returns : a string
\& Args    : none
\& Status  : Public
.Ve
.PP
Examine or change the reference sequence. This is an alias to
\&\fIsourceseq()\fR, provided here for \s-1API\s0 compatibility with
Bio::DB::GFF::RelSegment.
.SS "ref"
.IX Subsection "ref"
.Vb 6
\& Title   : ref
\& Usage   : $s\->refseq
\& Function: get or set the reference sequence
\& Returns : a string
\& Args    : none
\& Status  : Public
.Ve
.PP
An alias for \fIrefseq()\fR
.SS "seq_id"
.IX Subsection "seq_id"
.Vb 6
\& Title   : seq_id
\& Usage   : $ref = $s\->seq_id
\& Function: get the reference sequence in a LocationI\-compatible way
\& Returns : a string
\& Args    : none
\& Status  : Public
.Ve
.PP
An alias for \fIrefseq()\fR but only allows reading.
.SS "truncated"
.IX Subsection "truncated"
.Vb 6
\& Title   : truncated
\& Usage   : $truncated = $s\->truncated
\& Function: Flag indicating that the segment was truncated during creation
\& Returns : A boolean flag
\& Args    : none
\& Status  : Public
.Ve
.PP
This indicates that the sequence was truncated during creation.  The
returned flag is undef if no truncation occurred.  If truncation did
occur, the flag is actually an array ref in which the first element is
true if truncation occurred on the left, and the second element
occurred if truncation occurred on the right.
.SS "Bio::RangeI Methods"
.IX Subsection "Bio::RangeI Methods"
The following Bio::RangeI methods are supported:
.PP
\&\fIoverlaps()\fR, \fIcontains()\fR, \fIequals()\fR,\fIintersection()\fR,\fIunion()\fR,\fIoverlap_extent()\fR
.SS "Bio::SeqI implementation"
.IX Subsection "Bio::SeqI implementation"
.SS "primary_id"
.IX Subsection "primary_id"
.Vb 6
\& Title   : primary_id
\& Usage   : $unique_implementation_key = $obj\->primary_id;
\& Function: Returns the unique id for this object in this
\&           implementation. This allows implementations to manage their
\&           own object ids in a way the implementation can control
\&           clients can expect one id to map to one object.
\&
\&           For sequences with no accession number, this method should
\&           return a stringified memory location.
\&
\& Returns : A string
\& Args    : None
\& Status  : Virtual
.Ve
.SS "display_name"
.IX Subsection "display_name"
.Vb 4
\& Title   : display_name
\& Usage   : $id = $obj\->display_name or $obj\->display_name($newid);
\& Function: Gets or sets the display id, also known as the common name of
\&           the Seq object.
\&
\&           The semantics of this is that it is the most likely string
\&           to be used as an identifier of the sequence, and likely to
\&           have "human" readability.  The id is equivalent to the LOCUS
\&           field of the GenBank/EMBL databanks and the ID field of the
\&           Swissprot/sptrembl database. In fasta format, the >(\eS+) is
\&           presumed to be the id, though some people overload the id
\&           to embed other information. Bioperl does not use any
\&           embedded information in the ID field, and people are
\&           encouraged to use other mechanisms (accession field for
\&           example, or extending the sequence object) to solve this.
\&
\&           Notice that $seq\->id() maps to this function, mainly for
\&           legacy/convenience issues.
\& Returns : A string
\& Args    : None or a new id
.Ve
.PP
Note, this used to be called \fIdisplay_id()\fR, and this name is preserved for
backward compatibility.  The default is to return the \fIseq_id()\fR.
.SS "accession_number"
.IX Subsection "accession_number"
.Vb 8
\& Title   : accession_number
\& Usage   : $unique_biological_key = $obj\->accession_number;
\& Function: Returns the unique biological id for a sequence, commonly
\&           called the accession_number. For sequences from established
\&           databases, the implementors should try to use the correct
\&           accession number. Notice that primary_id() provides the
\&           unique id for the implementation, allowing multiple objects
\&           to have the same accession number in a particular implementation.
\&
\&           For sequences with no accession number, this method should return
\&           "unknown".
\& Returns : A string
\& Args    : None
.Ve
.SS "alphabet"
.IX Subsection "alphabet"
.Vb 4
\& Title   : alphabet
\& Usage   : if( $obj\->alphabet eq \*(Aqdna\*(Aq ) { /Do Something/ }
\& Function: Returns the type of sequence being one of
\&           \*(Aqdna\*(Aq, \*(Aqrna\*(Aq or \*(Aqprotein\*(Aq. This is case sensitive.
\&
\&           This is not called <type> because this would cause
\&           upgrade problems from the 0.5 and earlier Seq objects.
\&
\& Returns : a string either \*(Aqdna\*(Aq,\*(Aqrna\*(Aq,\*(Aqprotein\*(Aq. NB \- the object must
\&           make a call of the type \- if there is no type specified it
\&           has to guess.
\& Args    : none
\& Status  : Virtual
.Ve
.SS "desc"
.IX Subsection "desc"
.Vb 6
\& Title   : desc
\& Usage   : $seqobj\->desc($string) or $seqobj\->desc()
\& Function: Sets or gets the description of the sequence
\& Example :
\& Returns : The description
\& Args    : The description or none
.Ve
.SS "species"
.IX Subsection "species"
.Vb 6
\& Title   : species
\& Usage   : $species = $seq\->species() or $seq\->species($species)
\& Function: Gets or sets the species
\& Example :
\& Returns : Bio::Species object
\& Args    : None or Bio::Species object
.Ve
.PP
See Bio::Species for more information
.SS "annotation"
.IX Subsection "annotation"
.Vb 6
\& Title   : annotation
\& Usage   : $ann = $seq\->annotation or $seq\->annotation($annotation)
\& Function: Gets or sets the annotation
\& Example :
\& Returns : Bio::Annotation object
\& Args    : None or Bio::Annotation object
.Ve
.PP
See Bio::Annotation for more information
.SS "is_circular"
.IX Subsection "is_circular"
.Vb 5
\& Title   : is_circular
\& Usage   : if( $obj\->is_circular) { /Do Something/ }
\& Function: Returns true if the molecule is circular
\& Returns : Boolean value
\& Args    : none
.Ve
.SH "BUGS"
.IX Header "BUGS"
Report them please.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
bioperl
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2001 Cold Spring Harbor Laboratory.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Jason Stajich <jason@bioperl.org>.
