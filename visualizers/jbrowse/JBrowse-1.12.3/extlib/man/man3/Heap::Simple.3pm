.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Heap::Simple 3pm"
.TH Heap::Simple 3pm "2008-01-27" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Heap::Simple \- Fast and easy to use classic heaps
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Heap::Simple;
\&
\&    # Create a heap
\&    my $heap = Heap::Simple\->new;
\&    my $heap = Heap::Simple\->new(%options);
\&
\&    # Put data in the heap
\&    $heap\->insert(@new_elements);
\&    # Put data in a "Object" or "Any" heap with a given key
\&    $heap\->key_insert($key1, $element1, $key2, $element2, ...);
\&
\&    # Extract the top value
\&    $element = $heap\->extract_top;      # croaks on an empty heap
\&    $element = $heap\->extract_first;    # returns undef on an empty heap
\&
\&    # Get the top value but leave it in the heap
\&    $element = $heap\->top;              # croaks on an empty heap
\&    $element = $heap\->first;            # returns undef on an empty heap
\&
\&    # Find the top key in the heap
\&    $top_key = $heap\->top_key;          # return infinity on an empty heap
\&                                        # croaks if there\*(Aqs no infinity
\&    $top_key = $heap\->first_key;        # returns undef   on an empty heap
\&
\&    # Ordered extract of all data whose key is not above a given value
\&    @elements = $heap\->extract_upto($max_key);
\&
\&    # Ordered extract of all data
\&    @elements = $heap\->extract_all;
\&
\&    # Empty the heap
\&    $heap\->clear;
\&
\&    # Find the number of elements
\&    $count = $heap\->count;
\&
\&    # Get all keys (not sorted)
\&    @keys = $heap\->keys;
\&    # Get all values (not sorted)
\&    @values = $heap\->values;
\&
\&    # Find the key corresponding to a value
\&    $key = $heap\->key($value);
\&
\&    # Get/Set user_data
\&    $user_data  = $heap\->user_data;
\&    $old_data   = $heap\->user_data($new_data);
\&
\&    # Get/Set infinity
\&    $infinity     = $heap\->infinity;
\&    $old_infinity = $heap\->infinity($new_data);
\&
\&    # Get the position of a key in an element
\&    $key_index    = $heap\->key_index;
\&    $key_name     = $heap\->key_name;
\&    $key_method   = $heap\->key_method;
\&    $key_function = $heap\->key_function;
\&
\&    # Return the value of several things that were set in new:
\&    $wrapped      = $heap\->wrapped;
\&    $max_count    = $heap\->max_count;
\&    $can_die      = $heap\->can_die;
\&    $dirty        = $heap\->dirty;
\&    $order        = $heap\->order;
\&    @elements     = $heap\->elements;
\&    $elements     = $heap\->elements;
\&
\&    # Move all elements out of each heap in @heaps and into $heap
\&    $heap\->absorb(@heaps);      # As if doing a repeated $heap\->insert
\&    $heap\->key_absorb(@heaps);  # As if doing a repeated $heap\->key_insert
\&
\&    # merge already sorted arrays into a new sorted array
\&    # This doesn\*(Aqt disturb the elements already in the heap
\&    my $merged_aref = $heap\->merge_arrays($aref1, $aref2, ...);
\&
\&    # Which class does the actual work ?
\&    $implementation = Heap::Simple\->implementation;
.Ve
.SH "EXAMPLE1"
.IX Header "EXAMPLE1"
When key and value are kept separate:
.PP
.Vb 2
\&    use Heap::Simple;
\&    my $heap = Heap::Simple\->new(elements => "Any");
\&
\&    $heap\->key_insert(8, "bar");
\&    $heap\->key_insert(5, "foo");
\&
\&    # This will print foo (5 is the lowest key)
\&    print "First value is ", $heap\->extract_top, "\en";
\&
\&    $heap\->key_insert(7, "baz");
\&
\&    # This will print baz (7 is the lowest key)
\&    print "Next value is ", $heap\->extract_top, "\en";
\&    # This will print bar (8 is now the lowest key)
\&    print "Next value is ", $heap\->extract_top, "\en";
.Ve
.SH "EXAMPLE2"
.IX Header "EXAMPLE2"
When the key is part of the value:
.PP
.Vb 4
\&    # This is purely for display, ignore it
\&    use Data::Dumper;
\&    $Data::Dumper::Indent = 0;
\&    $Data::Dumper::Terse = 1;
\&
\&    # Real code starts here
\&    use Heap::Simple;
\&    my $heap = Heap::Simple\->new(elements => "Array");
\&
\&    $heap\->insert([8, "bar"]);
\&    $heap\->insert([5, "foo"]);
\&
\&    # This will print [5, foo] (5 is the lowest key)
\&    print "First value is ", Dumper($heap\->extract_top), "\en";
\&
\&    $heap\->insert([7, "baz"]);
\&
\&    # This will print [7, baz] (7 is the lowest key)
\&    print "Next value is ", Dumper($heap\->extract_top), "\en";
\&    # This will print [8, bar] (8 is now the lowest key)
\&    print "Next value is ", Dumper($heap\->extract_top), "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A heap is a partially sorted structure where it's always easy to extract the
smallest element. If the collection of elements is changing dynamically, a
heap has less overhead than keeping the collection fully sorted.
.PP
The order in which equal elements get extracted is unspecified.
.PP
The main order relations supported by this module are \*(L"<\*(R" (numeric compare)
and \*(L"lt\*(R" (string compare).
.PP
The module allows you to manage data where the elements are of several
allowed types, in particular array references, hash references, objects
or just the keys themselves.
.PP
So new has a lot of ways to specify element types, but the right
choices follows quite directly from the data you'll put in the heap. If the key
is part of the data (or easily derived from the data), choose an element
type that tells how to get the key out of the data, and insert elements
using insert. If the key is independent from the data or
you want to avoid repeated key calculations, use the Any element
type and insert elements using key_insert.
.PP
The internals of the module do nothing with the elements inserted except
inspecting the key. This means that if you for example store a blessed
object, that's what you will get back on extract. It's also ok to keep
references to the elements around and make changes to them while they are
in the heap as long as you don't change the key.
.PP
Heap::Simple itself is just a loader for the code that will actually implement
the functionality mentioned above. You will need to install something like
Heap::Simple::XS or
Heap::Simple::Perl to be able to actually do anything.
.SH "EXPORT"
.IX Header "EXPORT"
None.
.SH "METHODS"
.IX Header "METHODS"
All methods that can fail will thrown an exception in case of failure
unless otherwise specified. For example, you don't have to explicitely
check the result of new, it will already thrown an exception in
case of bad arguments.
.ie n .IP "my $heap = Heap::Simple\->new" 4
.el .IP "my \f(CW$heap\fR = Heap::Simple\->new" 4
.IX Xref "new"
.IX Item "my $heap = Heap::Simple->new"
This simplest form creates a new (empty) heap object able to hold numeric keys.
.Sp
You could for example use this to print a list of numbers from low to high:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new;
\&    $heap\->insert(8, 3, 14, \-1, 3);
\&    print $heap\->extract_top, " " for 1..$heap\->count;
\&    print "\en";
\&    # Will print: \-1 3 3 8 14
.Ve
.Sp
This example is silly of course. You could just as well directly use
perl sort. But in real applications you would do the
inserting interleaved with extracting and always keeping the list sorted
would become inefficient for big lists. That is where you would use a heap.
The examples we give will however be like the one above so you can quickly
see the way in which the methods are supposed to be called.
.Sp
For some applications this basic usage where you just store numeric keys will
be good enough, but usually you want to be able to store more complex elements.
.Sp
Several options can help you with that:
.RS 4
.ie n .IP "order => $order" 2
.el .IP "order => \f(CW$order\fR" 2
.IX Xref "new_order"
.IX Item "order => $order"
\&\f(CW$order\fR indicates what operation is used to compare keys. Supported orders are:
.RS 2
.IP "<" 2
Indicates that keys are compared as numbers, and extraction is lowest value
first. This is actually the default order, so the example above could have
used:
.Sp
.Vb 1
\&    my $heap = Heap::Simple\->new(order => "<");
.Ve
.Sp
and the result would have been exactly the same.
.Sp
The default infinity for this order is +inf.
.IP ">" 2
Indicates that keys are compared as numbers, and extraction is highest value
first.
.Sp
Repeating the example with this order gives:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new(order => ">");
\&    $heap\->insert(8, 3, 14, \-1, 3);
\&    print $heap\->extract_top, " " for 1..$heap\->count;
\&    print "\en";
\&    # Will print: 14 8 3 3 \-1
.Ve
.Sp
The default infinity for this order is \-inf.
.IP "lt" 2
.IX Item "lt"
Indicates that the keys are compared as strings, and extraction is lowest
value first. So we could modify the \*(L"<\*(R" example to:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new(order => "lt");
\&    $heap\->insert("ate", 8, 3, "zzzz", 14, \-1, 3, "at");
\&    print $heap\->extract_top, " " for 1..$heap\->count;
\&    print "\en";
\&    # Will print: \-1 14 3 3 8 at ate zzzz
.Ve
.Sp
Notice how 14 comes before 3 as you would expect in lexical sorting.
.Sp
The default infinity for this order is \*(L"undef\*(R" (there is no maximum string)
.IP "gt" 2
.IX Item "gt"
Indicates that the keys are compared as strings, and extraction is highest
value first. The concept of \*(L"minimum\*(R" again becomes rather confusing.
The standard example now becomes:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new(order => "gt");
\&    $heap\->insert("ate", 8, 3, "zzzz", 14, \-1, 3, "at");
\&    print $heap\->extract_top, " " for 1..$heap\->count;
\&    print "\en";
\&    # Will print: zzzz ate at 8 3 3 14 \-1
.Ve
.Sp
The default infinity for this order is "" (the empty string)
.ie n .IP "$code_reference" 2
.el .IP "\f(CW$code_reference\fR" 2
.IX Xref "CODE"
.IX Item "$code_reference"
If your keys are completely weird things, ordered neither as numbers nor as
strings and you need a special compare function, you can use this general
ordering type.
.Sp
Every time two keys need to be compared, the given code reference will be
called like:
.Sp
.Vb 1
\&    $less = $code_reference\->($key1, $key2);
.Ve
.Sp
This should return a true value if \f(CW$key1\fR is smaller than \f(CW$key2\fR and a false
value otherwise. \f(CW$code_reference\fR should imply a total order relation, so it
needs to be transitive.
.Sp
Since in this case nothing can be determined about the key type, there will
be no infinity by default (even if the keys are numbers).
.Sp
Example:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    sub more { return $_[0] > $_[1] }
\&
\&    my $heap = Heap::Simple\->new(order => \e&more);
\&    $heap\->insert(8, 3, 14, \-1, 3);
\&    print $heap\->extract_top, " " for 1..$heap\->count;
\&    print "\en";
\&    # Will print: 14 8 3 3 \-1
.Ve
.Sp
The code reference will be called many times during normal heap operations
(O(log n) times for a single insert or extract on a size n heap), so only use
this order type within reason. Usually it's better to precalculate some number
or string representation of some sort of key and use normal compares on these.
You can use the Any element type and key_insert to
wrap the precalculated key with the corresponding element, or you can delegate
the key calculation to the insert method and use one of the
Method, Object or Function element types.
.Sp
Here's an example of such \*(L"fake\*(R" keys:
.Sp
.Vb 2
\&    # "human" sorting mixed strings
\&    use Heap::Simple;
\&
\&    sub key {
\&        my $str = uc(shift);
\&        $str =~ s|(0*)(\ed+)|pack("AN/A*N", "0", $2, length($1))|eg;
\&        return $str;
\&    }
\&
\&    my $heap = Heap::Simple\->new(order => "lt",
\&                                 elements => [Function => \e&key]);
\&    $heap\->insert(qw(Athens5.gr Athens40.gr
\&                     Amsterdam51.nl Amsterdam5.nl amsterdam20.nl));
\&    print $heap\->extract_top, "\en" for 1..$heap\->count;
\&    # This will print:
\&    Amsterdam5.nl
\&    amsterdam20.nl
\&    Amsterdam51.nl
\&    Athens5.gr
\&    Athens40.gr
.Ve
.RE
.RS 2
.RE
.ie n .IP "elements => $element_type" 2
.el .IP "elements => \f(CW$element_type\fR" 2
.IX Xref "new_elements"
.IX Item "elements => $element_type"
This option describes what sort of elements we will store in the heap.
The only reason the module needs to know this is to determine how to access
the key values.
.Sp
The \f(CW$element_type\fR is usually an array reference, but if the array has only
one entry, you may use that directly. So you can use:
.Sp
.Vb 1
\&    elements => "Scalar"
.Ve
.Sp
instead of:
.Sp
.Vb 1
\&    elements => ["Scalar"]
.Ve
.Sp
The following element types are currently supported:
.RS 2
.ie n .IP "[""Scalar""]" 2
.el .IP "[``Scalar'']" 2
.IX Xref "Scalar"
.IX Item "[Scalar]"
Indicates that the elements are the keys themselves. This is the default if no
elements option is provided. So the constructor in the previous example could
also have been written as:
.Sp
.Vb 2
\&    my $heap = Heap::Simple\->new(order => "lt",
\&                                 elements => ["Scalar"]);
.Ve
.Sp
or in the simplified notation:
.Sp
.Vb 1
\&    my $heap = Heap::Simple\->new(order => "lt", elements => "Scalar");
.Ve
.Sp
This element type used to be called \f(CW\*(C`Key\*(C'\fR, and that name is still accepted
for backward compatibility.
.ie n .IP "[Array => $index]" 2
.el .IP "[Array => \f(CW$index\fR]" 2
.IX Xref "Array"
.IX Item "[Array => $index]"
Indicates that the elements are array references, with the key at index \f(CW$index\fR.
So now the element can be not just the key, but also associated data. We can
use this to for example print the values of a hash ordered by key:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new(order => "lt",
\&                                 elements => [Array => 0]);
\&    while (my ($key, $val) = each %hash) {
\&        $heap\->insert([$key, $val]);
\&    }
\&    for (1..$heap\->count) {
\&        print $heap\->extract_top\->[1], "\en";
\&    }
.Ve
.Sp
You can always use something like [$key, \f(CW@data\fR] to pair up keys and data,
so the \*(L"Array\*(R" element type is rather generally useful (but see the
Object and Any element types for another way to pair
keys with data). Since it's so common to have the key in the first position,
you may in fact drop the index in that case, so the constructor in the
previous example could also be written as:
.Sp
.Vb 2
\&    my $heap = Heap::Simple\->new(order => "lt",
\&                                 elements => ["Array"]);
.Ve
.Sp
or using the one element rule:
.Sp
.Vb 2
\&    my $heap = Heap::Simple\->new(order => "lt",
\&                                 elements => "Array");
.Ve
.Sp
In case the elements you want to store are arrays (or array based objects
(or fields based objects) and you are prepared to break the object
encapsulation), this element type is also very nice. If for example the value
on which you want to order is a number at position 4, you could use:
.Sp
.Vb 3
\&    my $heap = Heap::Simple\->new(elements => [Array => 4]);
\&    print "The key is $object\->[4]\en";
\&    $heap\->insert($object);
.Ve
.ie n .IP "[Hash => $key_name]" 2
.el .IP "[Hash => \f(CW$key_name\fR]" 2
.IX Xref "Hash"
.IX Item "[Hash => $key_name]"
Indicates that the elements are hash references, where the key (for the heap
element) is the value \f(CW$element\fR\->{$key_name} .
.Sp
Redoing the Array example in Hash style gives:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new(order => "lt",
\&                                 elements => [Hash => "tag"]);
\&    while (my ($key, $val) = each %hash) {
\&        $heap\->insert({tag => $key, value => $val});
\&    }
\&    for (1..$heap\->count) {
\&        print $heap\->extract_top\->{value}, "\en";
\&    }
.Ve
.Sp
In case the elements you want to store are hashes (or hash based objects and
you are prepared to break the object encapsulation), this element type is also
very nice. If for example the value on which you want to order is a number
with key \*(L"price\*(R", you could use:
.Sp
.Vb 3
\&    my $heap = Heap::Simple\->new(elements => [Hash => "price"]);
\&    print "The key is $object\->{price}\en";
\&    $heap\->insert($object);
.Ve
.ie n .IP "[Method => $method_name]" 2
.el .IP "[Method => \f(CW$method_name\fR]" 2
.IX Xref "Method"
.IX Item "[Method => $method_name]"
In case you don't want to (or can't) break the object encapsulation, but there
is a method that will return the key for a given object, you can use this.
.Sp
The method method_name will be called like:
.Sp
.Vb 1
\&    $key = $element\->$method_name();
.Ve
.Sp
and should return the key corresponding to \f(CW$element\fR.
.Sp
Suppose that the elements are objects whose weight you can access using the
\&\*(L"weight\*(R" method. A heap ordered on weight then becomes:
.Sp
.Vb 3
\&    my $heap = Heap::Simple\->new(elements => [Method => "weight"]);
\&    print "The key is ", $object\->weight(), "\en";
\&    $heap\->insert($object);
.Ve
.ie n .IP "[Object => $method_name]" 2
.el .IP "[Object => \f(CW$method_name\fR]" 2
.IX Xref "Object"
.IX Item "[Object => $method_name]"
The drawback of the \*(L"Method\*(R" element type is that the method will
be called every time the internals need ordering information, which will be
O(log n) for a single insert or extract on a heap of size n. So it's usually
better to first extract the key before insert, wrap the object with the key
such that key access is cheap and insert that. Since this is so common,
this element type is provided for that.
.Sp
So this element type will only call \f(CW$method_name\fR once on the initial insert,
after which internally the key is stored together with the value. This makes
it faster, but it also uses more memory.
.Sp
It also means that it's now perfectly fine to make changes to the object
that change the key while it is in the heap. This will have absolutely no
influence on the ordering anymore, and methods like first_key
will still return what the key value was at insert time.
.Sp
Repeating the previous example in this style is a trivial variation:
.Sp
.Vb 3
\&    my $heap = Heap::Simple\->new(elements => [Object => "weight"]);
\&    print "The key is ", $object\->weight(), "\en";
\&    $heap\->insert($object);
.Ve
.Sp
Since for this element type the key is almost completely decoupled from the
value and only fetched on insert, it often makes sense to not let the heap
calculate the key, but do it yourself before the insert, and then use
key_insert. In fact, if you never use plain insert
at all, you don't even have to bother passing a method name (though in that
case the fact that the thing you store is an object is pretty irrelevant and
it's probable more natural to use the Any element type).
.ie n .IP "[Function => $code_reference]" 2
.el .IP "[Function => \f(CW$code_reference\fR]" 2
.IX Xref "Function"
.IX Item "[Function => $code_reference]"
For completely general key calculation you can use this element type. The given
code reference will be called on an element like:
.Sp
.Vb 1
\&    $key = $code_reference\->($element);
.Ve
.Sp
and should return the key corresponding to \f(CW$element\fR.
.Sp
An example:
.Sp
.Vb 6
\&    sub price {
\&        my $items = shift;
\&        my $price = 0;
\&        $price += $_\->price for @$items;
\&        return $price;
\&    }
\&
\&    my $heap = Heap::Simple\->new(elements => [Function => \e&price]);
\&    print "All items together will cost ", $item_list\->price, "\en";
\&    $heap\->insert($item_list);
.Ve
.ie n .IP "[Any => $code_reference]" 2
.el .IP "[Any => \f(CW$code_reference\fR]" 2
.IX Xref "Any"
.IX Item "[Any => $code_reference]"
The same discussion as under Object applies for
Function: single insert and extract on a size n heap will call
the code reference O(log n) times, which could get slow.
.Sp
So if you are prepared to use more memory, you can again tell Heap::Simple
to calculate the key already at insert time, and store it together with the
value. This will avoid the need for repeated key calculations.
.Sp
The \*(L"Any\*(R" element type will do this for you transparantly.
.Sp
The heap part of the above example becomes:
.Sp
.Vb 3
\&    my $heap = Heap::Simple\->new(elements => [Any => \e&price]);
\&    print "All items together will cost ", $item_list\->price, "\en";
\&    $heap\->insert($item_list);
.Ve
.Sp
Since for this element type the key is almost completely decoupled from the
value and only fetched on insert, it often makes sense to not let the heap
calculate the key, but do it yourself before the insert, and then use
key_insert. In fact, if you never use plain insert
at all, you don't even have to bother passing the code reference. So the last
example could look like:
.Sp
.Vb 4
\&    my $heap = Heap::Simple\->new(elements => "Any");
\&    my $price = $item_list\->price;
\&    print "All items together will cost $price\en";
\&    $heap\->key_insert($price, $item_list);
.Ve
.Sp
Or we can use it to simplify the hash sort on key example a bit:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new(order => "lt",
\&                                 elements => "Any");
\&    # A hash in list context returns a sequence of key/value pairs
\&    $heap\->key_insert(%hash);
\&    for (1..$heap\->count) {
\&        print $heap\->extract_top, "\en";
\&    }
.Ve
.RE
.RS 2
.RE
.ie n .IP "max_count => $natural_number" 2
.el .IP "max_count => \f(CW$natural_number\fR" 2
.IX Xref "new_max_count"
.IX Item "max_count => $natural_number"
Normally a heap can contain any number of elements. By passing a positive
integer as argument to max_count, you tell the heap that it should never
contain more values than that. If you try to insert something new when the
maximum is reached, the lowest element (with respect to the current order) is
dropped (the thing just being inserted is among the candidates for dropping).
.Sp
A max count of 0 may or may not be supported depending on the implementor.
.Sp
You can for example use this to efficiently determine the three highest values
in an array:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my @array = qw(19 3 7 \-5 3 18 1);
\&
\&    my $heap = Heap::Simple\->new(max_count => 3);
\&    $heap\->insert(@array);
\&    print "The three highest values are: ", join(", " => $heap\->values), "\en";
\&
\&    # Will print: The three highest values are: 7, 19, 18
.Ve
.ie n .IP "can_die => $bool" 2
.el .IP "can_die => \f(CW$bool\fR" 2
.IX Xref "new_can_die"
.IX Item "can_die => $bool"
If you use magic values, overload, order functions or
key access functions, then it's possible for external perl
code to run when you do heap operations like insert or
extract_top. If these throw an exception, the heap can
be left in an incorrect half changed state.
.Sp
If you give a true value to can_die, the code for single element operations
will be changed so that they will properly recover by undoing what just got
changed (so a failing operation becomes a no-op). This however will slow down
these operations somewhat, so the default is actually false (most of the time
getting exceptions during the heap operations is impossible anyways).
.Sp
Operations that insert or extract multiple elements will also get their code
changed so the heap is always left in a consistent state, but the operation
is not atomic since it could already be executed on some of the elements.
You could even lose elements if for example an extract_all
fails halfway through (the already extracted part is gone from the heap but you
never got a chance to store the methods return values).
.Sp
Multi element operations can be substantially more efficient without this flag
since it may allow the use of better algorithms.
.Sp
This is a per heap option, so only those heaps that actually set this will
see any slowdown.
.Sp
All operations that don't change the heap (like count or
top) are always safe.
.Sp
Note that all change operations always assume you won't recursively cause
another change to the same heap while they are running. If you do that, all
bets for consistency are are off, even if you set this option.
.ie n .IP "dirty => $bool" 2
.el .IP "dirty => \f(CW$bool\fR" 2
.IX Xref "dirty"
.IX Item "dirty => $bool"
Giving this option a true value means that the code may make optimistic
assumptions to gain more speed. These can be things like for example ignoring
overloads, casting all numbers to doubles, ignoring locale for string order,
caching keys etc. The particular optimizations done under dirty will be safe
for most applications though. See the documentation for a particular
implementor (like Heap::Simple::XS or
Heap::Simple::Perl) for what the dirty option does for
that package.
.Sp
The default is no dirty optimizations.
.ie n .IP "user_data => $user_data" 2
.el .IP "user_data => \f(CW$user_data\fR" 2
.IX Xref "new_user_data"
.IX Item "user_data => $user_data"
You can associate one scalar worth of user data with any heap. That scalar can
of course also be a reference to a more complex data structure, allowing you to
effectively associate any amount of data with the heap. This option allows you
to set this scalar value already at object creation. You can use the
user_data method to get/set the associated value.
.Sp
If this option is not given, the heap starts with \*(L"undef\*(R" associated to it.
.Sp
.Vb 3
\&    my $heap = Heap::Simple\->new(user_data => "foo");
\&    print $heap\->user_data, "\en";
\&    # prints foo
.Ve
.ie n .IP "infinity => $infinity" 2
.el .IP "infinity => \f(CW$infinity\fR" 2
.IX Xref "new_infinity"
.IX Item "infinity => $infinity"
Associates \f(CW$infinity\fR as the highest possible key with the created heap.
($infinity may or may not be a possible key itself).
Setting it to \*(L"undef\*(R" means there is no infinity associated with the heap.
.Sp
The default value depends on the order relation that was
specified.
.Sp
Usually you can just forget about this option. Only top_key
really cares.
.RE
.RS 4
.Sp
Notice that the class into which the resulting heap is blessed will \fBnot\fR
be Heap::Simple. It will be an on demand generated class that will have
Heap::Simple as an ancestor.
.RE
.ie n .IP "$heap\->insert(@new_elements)" 4
.el .IP "\f(CW$heap\fR\->insert(@new_elements)" 4
.IX Xref "insert"
.IX Item "$heap->insert(@new_elements)"
Inserts each of the \f(CW@new_elements\fR in the heap. On extraction you get back
exactly the same \f(CW$element\fR as you inserted, including a possible
blessing.
.Sp
In case an exception is raised during insert the heap is only guaranteed to be
in a consistent state if you had set the can_die flag to
new. Even then it's possible that some first part of \f(CW@new_elements\fR has
been inserted into the heap while the rest hasn't (they get inserted in the
order given). You could check how many by calling the count method
before and after the insert. So even with can_die only
inserts of single elements are atomic.
.Sp
Mass insert can be substantially faster if the can_die flag
isn't set though.
.ie n .IP "$heap\->key_insert($key1, $element1, $key2, $element2, ...)" 4
.el .IP "\f(CW$heap\fR\->key_insert($key1, \f(CW$element1\fR, \f(CW$key2\fR, \f(CW$element2\fR, ...)" 4
.IX Xref "key_insert"
.IX Item "$heap->key_insert($key1, $element1, $key2, $element2, ...)"
Inserts each \f(CW$element\fR in the heap ordered by the \f(CW$key\fR given just before it.
Since in this case the key must be stored seperately from the element, this
method only exists for \*(L"Object\*(R" and \*(L"Any\*(R" heaps.
.Sp
On extraction you get back exactly the same \f(CW$element\fR as you inserted,
including a possible blessing.
.Sp
In case an exception is raised during insert the heap is only guaranteed to be
in a consistent state if you had set the can_die flag to
new. Even then it's possible that some first part of the argument list
has been inserted into the heap while the rest hasn't (they get inserted in
the order given). You could check how many by calling
the count method before and after the insert. So even with
can_die only inserts of single key/element pairs are atomic.
.Sp
Mass insert can be substantially faster if the can_die flag
isn't set though.
.ie n .IP "$element = $heap\->extract_top" 4
.el .IP "\f(CW$element\fR = \f(CW$heap\fR\->extract_top" 4
.IX Xref "extract_top"
.IX Item "$element = $heap->extract_top"
For all elements in the heap, find the top one (the one that is \*(L"lowest\*(R" in the
order relation), remove it from the heap and return it.
.Sp
This method used to be called \f(CW"extract_min"\fR instead of \f(CW"extract_top"\fR.
The old name is still supported but is deprecated.
.Sp
Throws an exception if the heap is empty.
.ie n .IP "$element = $heap\->extract_first" 4
.el .IP "\f(CW$element\fR = \f(CW$heap\fR\->extract_first" 4
.IX Xref "extract_first"
.IX Item "$element = $heap->extract_first"
Like extract_top, but if the heap is empty it will
return undef (in scalar context).
.ie n .IP "$element = $heap\->top" 4
.el .IP "\f(CW$element\fR = \f(CW$heap\fR\->top" 4
.IX Xref "top"
.IX Item "$element = $heap->top"
For all elements in the heap, find the top one (the one that is \*(L"lowest\*(R" in the
order relation) and return it (without removing it from the heap)..
.Sp
Throws an exception if the heap is empty.
.ie n .IP "$element = $heap\->first" 4
.el .IP "\f(CW$element\fR = \f(CW$heap\fR\->first" 4
.IX Xref "first"
.IX Item "$element = $heap->first"
For all elements in the heap, find the top one (the one that is \*(L"lowest\*(R" in the
order relation) and return it (without removing it from the heap).For all elements in the heap, find the one with the lowest key and return it.
Returns undef (in scalar context) in case the heap is empty. The contents of
the heap remain unchanged.
.Sp
Since the data returned from a non-empty heap can often not be undef, you
could use this method to check if a heap is empty, but it's probably more
natural to use count for that.
.Sp
Example:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new;
\&    $heap\->insert(8, 3, 14, \-1, 3);
\&    print $heap\->first, "\en";
\&    # prints \-1
.Ve
.ie n .IP "$top_key = $heap\->first_key" 4
.el .IP "\f(CW$top_key\fR = \f(CW$heap\fR\->first_key" 4
.IX Xref "first_key"
.IX Item "$top_key = $heap->first_key"
Looks for the lowest key in the heap and returns its value. Returns undef
(in scalar context) in case the heap is empty
.Sp
Example:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new;
\&    $heap\->insert(8, 3, 14, \-1, 3);
\&    print $heap\->first_key, "\en";
\&    # prints \-1
.Ve
.ie n .IP "$top_key = $heap\->top_key" 4
.el .IP "\f(CW$top_key\fR = \f(CW$heap\fR\->top_key" 4
.IX Xref "top_key"
.IX Item "$top_key = $heap->top_key"
Looks for the lowest key in the heap and returns its value. Returns the highest
possible value (the infinity for the chosen order) in case the heap is empty.
If there is no infinity, it will throw an exception.
.Sp
Example:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new;
\&    $heap\->insert(8, 3, 14, \-1, 3);
\&    print $heap\->top_key, "\en";
\&    # prints \-1
.Ve
.Sp
This method used to be called \*(L"min_key\*(R" instead of \*(L"top_key\*(R". The old name is
still supported but is deprecated.
.ie n .IP "@elements = $heap\->extract_upto($max_key)" 4
.el .IP "\f(CW@elements\fR = \f(CW$heap\fR\->extract_upto($max_key)" 4
.IX Xref "extract_upto"
.IX Item "@elements = $heap->extract_upto($max_key)"
Finds all elements in the heap whose key is not above \f(CW$value\fR and removes them
from the heap (so elements with key equal to \f(CW$max_key\fR get extracted too).
The list of removed elements is returned ordered by key value (low to high
with repect to the heap order).
.Sp
Returns an empty list for the empty heap.
.Sp
Example:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new;
\&    $heap\->insert(8, 3, 14, \-1, 3);
\&    print join(", ", $heap\->extract_upto(3)), "\en";
\&    # prints \-1, 3, 3
.Ve
.Sp
This method will lose values in case of an exception even if
can_die is true (remember that exceptions of this type are
only possible if you have a self coded key fetch or compare that can die, so
this is normally irrelevant).
.ie n .IP "@elements = $heap\->extract_all" 4
.el .IP "\f(CW@elements\fR = \f(CW$heap\fR\->extract_all" 4
.IX Xref "extract_all"
.IX Item "@elements = $heap->extract_all"
Extracts all elements from \f(CW$heap\fR and returns them ordered by key value (low to
high with repect to the heap order).
.Sp
Example:
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new;
\&    $heap\->insert(8, 3, 14, \-1, 3);
\&    print join(", ", $heap\->extract_all), "\en";
\&    # prints \-1, 3, 3, 8, 14
.Ve
.Sp
This method can lose values in case of an exception even if
can_die is true (remember that exceptions of this type are
only possible if you have a key fetch or compare that can die, so this is
normally irrelevant).
.Sp
If you don't actually care about the order of the elements it's more efficient
to use values followed by clear.
.Sp
It's unspecified what this method returns in scalar context.
.ie n .IP "$heap\->clear" 4
.el .IP "\f(CW$heap\fR\->clear" 4
.IX Xref "clear"
.IX Item "$heap->clear"
Removes all elements from the heap. This can be much more efficient than using
extract_all in a void context.
.ie n .IP "$count = $heap\->count" 4
.el .IP "\f(CW$count\fR = \f(CW$heap\fR\->count" 4
.IX Xref "count"
.IX Item "$count = $heap->count"
Returns the number of elements in the heap.
This is an constant time operation, it doesn't really need to count anything.
.Sp
.Vb 1
\&    use Heap::Simple;
\&
\&    my $heap = Heap::Simple\->new;
\&    $heap\->insert(8, 3, 14, \-1, 3);
\&    print $heap\->count, "\en";
\&    # prints 5
.Ve
.ie n .IP "@keys = $heap\->keys" 4
.el .IP "\f(CW@keys\fR = \f(CW$heap\fR\->keys" 4
.IX Xref "keys"
.IX Item "@keys = $heap->keys"
Returns the keys of all elements in the heap in some heap order.
This means that the element at index n is not bigger (in the heap order)
than the element at index 2*n+1 and 2*n+2. So the top key will in fact be
in the first position, but don't expect the whole list to be ordered.
.Sp
This method may imply a lot of function calls if getting the key from an
element implies a function call (as it does for the Method and
Function element types, but not for the Object and
Any element types).
.Sp
Multiple calls to an unchanged heap will return the keys in the same order,
which is also consistent with the order of values
.ie n .IP "@values = $heap\->values" 4
.el .IP "\f(CW@values\fR = \f(CW$heap\fR\->values" 4
.IX Xref "values"
.IX Item "@values = $heap->values"
Returns all elements in the heap in some heap order with respect to the
corresponding keys (see keys).
Does not remove the values from the heap.
.Sp
Multiple calls to an unchanged heap will return the values in the same order,
which is also consistent with the order of keys
.ie n .IP "$key = $heap\->key($value)" 4
.el .IP "\f(CW$key\fR = \f(CW$heap\fR\->key($value)" 4
.IX Xref "key"
.IX Item "$key = $heap->key($value)"
Calculates the key corresponding to \f(CW$value\fR in the same way as the internals
of \f(CW$heap\fR would. Can fail for Object and Any element
types if there was no method or function given on heap creation.
.Sp
Notice that this does not access the elements in the heap in any way.
In particular, it's \fBnot\fR looking for \f(CW$value\fR in the heap hoping to match its
key.
.ie n .IP "$user_data = $heap\->user_data" 4
.el .IP "\f(CW$user_data\fR = \f(CW$heap\fR\->user_data" 4
.IX Xref "user_data"
.IX Item "$user_data = $heap->user_data"
Queries the user_data associated with the heap.
.ie n .IP "$old_data = $heap\->user_data($new_data)" 4
.el .IP "\f(CW$old_data\fR = \f(CW$heap\fR\->user_data($new_data)" 4
.IX Item "$old_data = $heap->user_data($new_data)"
Associates new user_data with the heap. Returns the old
value.
.ie n .IP "$infinity = $heap\->infinity" 4
.el .IP "\f(CW$infinity\fR = \f(CW$heap\fR\->infinity" 4
.IX Xref "infinity"
.IX Item "$infinity = $heap->infinity"
Queries the infinity value associated with the heap. Returns undef if there
is none. The default infinity is implied by the chosen order relation.
.ie n .IP "$old_infinity = $heap\->infinity($new_infinity)" 4
.el .IP "\f(CW$old_infinity\fR = \f(CW$heap\fR\->infinity($new_infinity)" 4
.IX Item "$old_infinity = $heap->infinity($new_infinity)"
Associates a new infinity with the heap. Returns the old value.
.ie n .IP "$key_index = $heap\->key_index" 4
.el .IP "\f(CW$key_index\fR = \f(CW$heap\fR\->key_index" 4
.IX Xref "key_index"
.IX Item "$key_index = $heap->key_index"
Returns the index of the key for array reference based heaps.
Doesn't exist for the other heap types.
.ie n .IP "$key_name = $heap\->key_name" 4
.el .IP "\f(CW$key_name\fR = \f(CW$heap\fR\->key_name" 4
.IX Xref "key_name"
.IX Item "$key_name = $heap->key_name"
Returns the name of the key key for hash reference based heaps.
Doesn't exist for the other heap types.
.ie n .IP "$key_name = $heap\->key_method" 4
.el .IP "\f(CW$key_name\fR = \f(CW$heap\fR\->key_method" 4
.IX Xref "key_method"
.IX Item "$key_name = $heap->key_method"
Returns the name of the method to fetch the key from an object. Only exists
for Method and Object based heaps.
.ie n .IP "$key_function = $heap\->key_function" 4
.el .IP "\f(CW$key_function\fR = \f(CW$heap\fR\->key_function" 4
.IX Xref "key_function"
.IX Item "$key_function = $heap->key_function"
Returns the code reference of the function to fetch the key from an element.
Only exists for \*(L"Function\*(R" and \*(L"Any\*(R" heaps.
.ie n .IP "$wrapped => $heap\->wrapped" 4
.el .IP "\f(CW$wrapped\fR => \f(CW$heap\fR\->wrapped" 4
.IX Xref "wrapped"
.IX Item "$wrapped => $heap->wrapped"
Returns true if key and value are stored seperately (wrapped together in
some internal container), nothing otherwise. This is the sufficient and
necessary condition for key_insert to work, and will normally
only be true for the \*(L"Any\*(R" and Object type heaps.
.ie n .IP "$max_count => $heap\->max_count" 4
.el .IP "\f(CW$max_count\fR => \f(CW$heap\fR\->max_count" 4
.IX Xref "max_count"
.IX Item "$max_count => $heap->max_count"
Returns the maximum size of the heap, or infinity if there is no maximum (the
default unless you used the max_count option).
.ie n .IP "$can_die = $heap\->can_die" 4
.el .IP "\f(CW$can_die\fR = \f(CW$heap\fR\->can_die" 4
.IX Xref "can_die"
.IX Item "$can_die = $heap->can_die"
Returns the can_die setting for this heap.
.ie n .IP "$dirty = $heap\->dirty" 4
.el .IP "\f(CW$dirty\fR = \f(CW$heap\fR\->dirty" 4
.IX Xref "dirty"
.IX Item "$dirty = $heap->dirty"
Returns the dirty setting for this heap.
.ie n .IP "$order = $heap\->order" 4
.el .IP "\f(CW$order\fR = \f(CW$heap\fR\->order" 4
.IX Xref "order"
.IX Item "$order = $heap->order"
Returns the order setting for this heap (either \f(CW"<"\fR, \f(CW">"\fR, \f(CW"lt"\fR, \f(CW"gt"\fR or a code reference).
.ie n .IP "@elements = $heap\->elements" 4
.el .IP "\f(CW@elements\fR = \f(CW$heap\fR\->elements" 4
.IX Xref "elements"
.IX Item "@elements = $heap->elements"
Returns the elements setting for this heap. The first entry
in the returned list is a string representing the type in canonical form
(\*(L"Scalar\*(R" or \*(L"Array\*(R" etc) followed by any arguments
that type needed (e.g. the key name for a Hash type).
.ie n .IP "$elements = $heap\->elements" 4
.el .IP "\f(CW$elements\fR = \f(CW$heap\fR\->elements" 4
.IX Xref "elements"
.IX Item "$elements = $heap->elements"
Like the list context version, but only returns the first entry (the canonical
type name).
.ie n .IP "$heap\->absorb(@heaps)" 4
.el .IP "\f(CW$heap\fR\->absorb(@heaps)" 4
.IX Xref "absorb"
.IX Item "$heap->absorb(@heaps)"
Takes all elements from each heap in \f(CW@heaps\fR and inserts them in \f(CW$heap\fR,
leaving each heap in \f(CW@heaps\fR empty. Behaves a bit like:
.Sp
.Vb 4
\&    for my $work_heap (@heaps) {
\&        $heap\->insert(reverse $work_heap\->values);
\&        $work_heap\->clear;
\&    }
.Ve
.Sp
except that it may be more efficient.
.Sp
If an exception is possible and gets raised during insert, the heaps will be
left in a consistent state with a partial transfer completed on the condition
that can_die is set for \f(CW$heap\fR (the settings for the heaps in
\&\f(CW@heaps\fR are irrelevant, their accesses will always be done in a safe way)
.ie n .IP "$heap\->key_absorb(@heaps)" 4
.el .IP "\f(CW$heap\fR\->key_absorb(@heaps)" 4
.IX Xref "key_absorb"
.IX Item "$heap->key_absorb(@heaps)"
Takes all elements from each heap in \f(CW@heaps\fR and key_inserts them in \f(CW$heap\fR,
leaving each heap in \f(CW@heaps\fR empty. Behaves a bit like:
.Sp
.Vb 6
\&    for my $work_heap (@heaps) {
\&        my @values = $work_heap\->values;
\&        my @keys   = $work_heap\->keys;
\&        $heap\->key_insert(pop @keys, pop @values) while @values;
\&        $work_heap\->clear;
\&    }
.Ve
.Sp
except that it's may be more efficient. This is mainly meant for transfer
between wrapped heap types (Any and Object) since it
avoids key recalculation. \f(CW$heap\fR must of course be a wrapped heap type.
.Sp
If an exception is possible and gets raised during insert, all heaps will be
left in a consistent state with a partial transfer completed on the condition
that can_die is set for \f(CW$heap\fR (the setting for the heaps in
\&\f(CW@heaps\fR are irrelevant, their accesses will always be done in a safe way)
.ie n .IP "my $merged_aref = $heap\->merge_arrays($aref1, $aref2, ...)" 4
.el .IP "my \f(CW$merged_aref\fR = \f(CW$heap\fR\->merge_arrays($aref1, \f(CW$aref2\fR, ...)" 4
.IX Xref "merge_arrays"
.IX Item "my $merged_aref = $heap->merge_arrays($aref1, $aref2, ...)"
This convenience function merges a sequence of references to already sorted
arrays into a new sorted array and returns its reference.
So it does something like
.Sp
.Vb 2
\&    $merge_aref = [sort { $heap\->compare_function\->($a, $b) } map @$_, @_;
\&    shift @$merge_aref until @$merge_aref <= $heap\->max_count;
.Ve
.Sp
except that it's more efficient (e.g. it uses the knowledge that the
argument arrays are already sorted).
.Sp
It leaves values stored in the \f(CW$heap\fR completely untouched. \f(CW$heap\fR is
only used for its attributes: how to find the key, what the compare function is
and the maximum number of elements.
.ie n .IP "$implementation = Heap::Simple\->implementation" 4
.el .IP "\f(CW$implementation\fR = Heap::Simple\->implementation" 4
.IX Xref "implementation"
.IX Item "$implementation = Heap::Simple->implementation"
Returns the package that does the actual work. That will probably be
\&\f(CW"Heap::Simple::XS"\fR or \f(CW"Heap::Simple::Perl"\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Heap::Simple::Perl,
Heap::Simple::XS
.PP
Some other heap or heap-like classes that exist:
.PP
Heap,
Heap::Priority,
Array::Heap2
.SH "AUTHOR"
.IX Header "AUTHOR"
Ton Hospel, <Heap\-Simple@ton.iguana.be>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2003 by Ton Hospel
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
