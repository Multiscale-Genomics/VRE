.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::SeqFeature::Store::berkeleydb 3"
.TH Bio::DB::SeqFeature::Store::berkeleydb 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::SeqFeature::Store::berkeleydb \-\- Storage and retrieval of sequence annotation data in Berkeleydb files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::DB::SeqFeature::Store;
\&
\&  # Create a database from the feature files located in /home/fly4.3 and store
\&  # the database index in the same directory:
\&  my $db = Bio::DB::SeqFeature::Store\->new( \-adaptor => \*(Aqberkeleydb\*(Aq,
\&                                            \-dir     => \*(Aq/home/fly4.3\*(Aq);
\&
\&  # Create a database that will monitor the files in /home/fly4.3, but store
\&  # the indexes in /var/databases/fly4.3
\&  $db    = Bio::DB::SeqFeature::Store\->new( \-adaptor => \*(Aqberkeleydb\*(Aq,
\&                                            \-dir     => \*(Aq/home/fly4.3\*(Aq,
\&                                            \-dsn     => \*(Aq/var/databases/fly4.3\*(Aq);
\&
\&  # Create a feature database from scratch
\&  $db    = Bio::DB::SeqFeature::Store\->new( \-adaptor => \*(Aqberkeleydb\*(Aq,
\&                                            \-dsn     => \*(Aq/var/databases/fly4.3\*(Aq,
\&                                            \-create  => 1);
\&
\&  # get a feature from somewhere
\&  my $feature = Bio::SeqFeature::Generic\->new(...);
\&
\&  # store it
\&  $db\->store($feature) or die "Couldn\*(Aqt store!";
\&
\&  # primary ID of the feature is changed to indicate its primary ID
\&  # in the database...
\&  my $id = $feature\->primary_id;
\&
\&  # get the feature back out
\&  my $f  = $db\->fetch($id);
\&
\&  # change the feature and update it
\&  $f\->start(100);
\&  $db\->update($f) or $self\->throw("Couldn\*(Aqt update!");
\&
\&  # use the GFF3 loader to do a bulk write:
\&  my $loader = Bio::DB::SeqFeature::Store::GFF3Loader\->new(\-store   => $db,
\&                                                           \-verbose => 0,
\&                                                           \-fast    => 1);
\&  $loader\->load(\*(Aq/home/fly4.3/dmel\-all.gff\*(Aq);
\&
\&
\&  # searching...
\&  # ...by id
\&  my @features = $db\->fetch_many(@list_of_ids);
\&
\&  # ...by name
\&  @features = $db\->get_features_by_name(\*(AqZK909\*(Aq);
\&
\&  # ...by alias
\&  @features = $db\->get_features_by_alias(\*(Aqsma\-3\*(Aq);
\&
\&  # ...by type
\&  @features = $db\->get_features_by_type(\*(Aqgene\*(Aq);
\&
\&  # ...by location
\&  @features = $db\->get_features_by_location(\-seq_id=>\*(AqChr1\*(Aq,\-start=>4000,\-end=>600000);
\&
\&  # ...by attribute
\&  @features = $db\->get_features_by_attribute({description => \*(Aqprotein kinase\*(Aq})
\&
\&  # ...by the GFF "Note" field
\&  @result_list = $db\->search_notes(\*(Aqkinase\*(Aq);
\&
\&  # ...by arbitrary combinations of selectors
\&  @features = $db\->features(\-name => $name,
\&                            \-type => $types,
\&                            \-seq_id => $seqid,
\&                            \-start  => $start,
\&                            \-end    => $end,
\&                            \-attributes => $attributes);
\&
\&  # ...using an iterator
\&  my $iterator = $db\->get_seq_stream(\-name => $name,
\&                                     \-type => $types,
\&                                     \-seq_id => $seqid,
\&                                     \-start  => $start,
\&                                     \-end    => $end,
\&                                     \-attributes => $attributes);
\&
\&  while (my $feature = $iterator\->next_seq) {
\&    # do something with the feature
\&  }
\&
\&  # ...limiting the search to a particular region
\&  my $segment  = $db\->segment(\*(AqChr1\*(Aq,5000=>6000);
\&  my @features = $segment\->features(\-type=>[\*(AqmRNA\*(Aq,\*(Aqmatch\*(Aq]);
\&
\&  # what feature types are defined in the database?
\&  my @types    = $db\->types;
\&
\&  # getting & storing sequence information
\&  # Warning: this returns a string, and not a PrimarySeq object
\&  $db\->insert_sequence(\*(AqChr1\*(Aq,\*(AqGATCCCCCGGGATTCCAAAA...\*(Aq);
\&  my $sequence = $db\->fetch_sequence(\*(AqChr1\*(Aq,5000=>6000);
\&
\&  # create a new feature in the database
\&  my $feature = $db\->new_feature(\-primary_tag => \*(AqmRNA\*(Aq,
\&                                 \-seq_id      => \*(Aqchr3\*(Aq,
\&                                 \-start      => 10000,
\&                                 \-end        => 11000);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::DB::SeqFeature::Store::berkeleydb is the Berkeleydb adaptor for
Bio::DB::SeqFeature::Store. You will not create it directly, but
instead use Bio::DB::SeqFeature::Store\->\fInew()\fR to do so.
.PP
See Bio::DB::SeqFeature::Store for complete usage instructions.
.SS "Using the berkeleydb adaptor"
.IX Subsection "Using the berkeleydb adaptor"
The Berkeley database consists of a series of Berkeleydb index files,
and a couple of special purpose indexes. You can create the index
files from scratch by creating a new database and calling
\&\fInew_feature()\fR repeatedly, you can create the database and then bulk
populate it using the \s-1GFF3\s0 loader, or you can monitor a directory of
preexisting \s-1GFF3\s0 and \s-1FASTA\s0 files and rebuild the indexes whenever one
or more of the fields changes. The last mode is probably the most
convenient. Note that the indexer will only pay attention to files
that end with .gff3, .wig and .fa.
.IP "The \fInew()\fR constructor" 4
.IX Item "The new() constructor"
The \fInew()\fR constructor method all the arguments recognized by
Bio::DB::SeqFeature::Store, and a few additional ones.
.Sp
Standard arguments:
.Sp
.Vb 2
\& Name               Value
\& \-\-\-\-               \-\-\-\-\-
\&
\& \-adaptor           The name of the Adaptor class (default DBI::mysql)
\&
\& \-serializer        The name of the serializer class (default Storable)
\&
\& \-index_subfeatures Whether or not to make subfeatures searchable
\&                    (default true)
\&
\& \-cache             Activate LRU caching feature \-\- size of cache
\&
\& \-compress          Compresses features before storing them in database
\&                    using Compress::Zlib
.Ve
.Sp
Adaptor-specific arguments
.Sp
.Vb 2
\& Name               Value
\& \-\-\-\-               \-\-\-\-\-
\&
\& \-dsn               Where the index files are stored
\&
\& \-dir               Where the source (GFF3, FASTA) files are stored
\&
\& \-autoindex         An alias for \-dir.
\&
\& \-write             Pass true to open the index files for writing.
\&
\& \-create            Pass true to create the index files if they don\*(Aqt exist
\&                    (implies \-write=>1)
\&
\& \-locking           Use advisory locking to avoid one process trying to read
\&                    from the database while another is updating it (may not
\&                    work properly over NFS).
\&
\& \-temp              Pass true to create temporary index files that will
\&                    be deleted once the script exits.
\&
\& \-verbose           Pass true to report autoindexing operations on STDERR.
\&                    (default is true).
.Ve
.Sp
Examples:
.Sp
To create an empty database which will be populated using calls to
\&\fIstore()\fR or \fInew_feature()\fR, or which will be bulk-loaded using the \s-1GFF3\s0
loader:
.Sp
.Vb 3
\&  $db     = Bio::DB::SeqFeature::Store\->new( \-adaptor => \*(Aqberkeleydb\*(Aq,
\&                                             \-dsn     => \*(Aq/var/databases/fly4.3\*(Aq,
\&                                             \-create  => 1);
.Ve
.Sp
To open a preexisting database in read-only mode:
.Sp
.Vb 2
\&  $db     = Bio::DB::SeqFeature::Store\->new( \-adaptor => \*(Aqberkeleydb\*(Aq,
\&                                             \-dsn     => \*(Aq/var/databases/fly4.3\*(Aq);
.Ve
.Sp
To open a preexisting database in read/write (update) mode:
.Sp
.Vb 3
\&  $db     = Bio::DB::SeqFeature::Store\->new( \-adaptor => \*(Aqberkeleydb\*(Aq,
\&                                             \-dsn     => \*(Aq/var/databases/fly4.3\*(Aq,
\&                                             \-write   => 1);
.Ve
.Sp
To monitor a set of \s-1GFF3\s0 and \s-1FASTA\s0 files located in a directory and
create/update the database indexes as needed. The indexes will be
stored in a new subdirectory named \*(L"indexes\*(R":
.Sp
.Vb 2
\&  $db     = Bio::DB::SeqFeature::Store\->new( \-adaptor => \*(Aqberkeleydb\*(Aq,
\&                                             \-dir     => \*(Aq/var/databases/fly4.3\*(Aq);
.Ve
.Sp
As above, but store the source files and index files in separate directories:
.Sp
.Vb 3
\&  $db     = Bio::DB::SeqFeature::Store\->new( \-adaptor => \*(Aqberkeleydb\*(Aq,
\&                                             \-dsn     => \*(Aq/var/databases/fly4.3\*(Aq,
\&                                             \-dir     => \*(Aq/home/gff3_files/fly4.3\*(Aq);
.Ve
.Sp
To be indexed, files must end with one of .gff3 (\s-1GFF3\s0 format), .fa
(\s-1FASTA\s0 format) or .wig (\s-1WIG\s0 format).
.Sp
\&\fB\-autoindex\fR is an alias for \fB\-dir\fR.
.Sp
You should specify \fB\-locking\fR in a multiuser environment, including
the case in which the database is being used by a web server at the
same time another user might be updating it.
.PP
See Bio::DB::SeqFeature::Store for all the access methods supported
by this adaptor. The various methods for storing and updating features
and sequences into the database are supported, but there is no
locking. If two processes try to update the same database
simultaneously, the database will likely become corrupted.
.SH "BUGS"
.IX Header "BUGS"
This is an early version, so there are certainly some bugs. Please
use the BioPerl bug tracking system to report bugs.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
bioperl,
Bio::DB::SeqFeature,
Bio::DB::SeqFeature::Store,
Bio::DB::SeqFeature::GFF3Loader,
Bio::DB::SeqFeature::Segment,
Bio::DB::SeqFeature::Store::memory,
Bio::DB::SeqFeature::Store::DBI::mysql,
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2006 Cold Spring Harbor Laboratory.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
