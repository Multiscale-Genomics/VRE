.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::SeqFeature::Store::FeatureFileLoader 3"
.TH Bio::DB::SeqFeature::Store::FeatureFileLoader 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::SeqFeature::Store::FeatureFileLoader \-\- feature file loader for Bio::DB::SeqFeature::Store
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Bio::DB::SeqFeature::Store;
\&  use Bio::DB::SeqFeature::Store::FeatureFileLoader;
\&
\&  # Open the sequence database
\&  my $db      = Bio::DB::SeqFeature::Store\->new( \-adaptor => \*(AqDBI::mysql\*(Aq,
\&                                                 \-dsn     => \*(Aqdbi:mysql:test\*(Aq,
\&                                                 \-write   => 1 );
\&
\&  my $loader = 
\&    Bio::DB::SeqFeature::Store::FeatureFileLoader\->new(\-store    => $db,
\&                                                       \-verbose  => 1,
\&                                                       \-fast     => 1);
\&
\&  $loader\->load(\*(Aq./my_genome.fff\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Bio::DB::SeqFeature::Store::FeatureFileLoader object parsers
FeatureFile-format sequence annotation files and loads
Bio::DB::SeqFeature::Store databases. For certain combinations of
SeqFeature classes and SeqFeature::Store databases it features a \*(L"fast
load\*(R" mode which will greatly accelerate the loading of databases by a
factor of 5\-10.
.PP
FeatureFile Format (.fff) is very simple:
.PP
.Vb 3
\& mRNA B0511.1 Chr1:1..100 Type=UTR;Note="putative primase"
\& mRNA B0511.1 Chr1:101..200,300..400,500..800 Type=CDS
\& mRNA B0511.1 Chr1:801..1000 Type=UTR
\&
\& reference = Chr3
\& Cosmid B0511   516..619
\& Cosmid B0511   3185..3294
\& Cosmid B0511   10946..11208
\& Cosmid B0511   13126..13511
\& Cosmid B0511   11394..11539
\& EST    yk260e10.5      15569..15724
\& EST    yk672a12.5      537..618,3187..3294
\& EST    yk595e6.5       552..618
\& EST    yk595e6.5       3187..3294
\& EST    yk846e07.3      11015..11208
\& EST    yk53c10
\&        yk53c10.3       15000..15500,15700..15800
\&        yk53c10.5       18892..19154
\& EST    yk53c10.5       16032..16105
\& SwissProt      PECANEX 13153\-13656     Note="Swedish fish"
\& FGENESH        "Predicted gene 1"      1\-205,518\-616,661\-735,3187\-3365,3436\-3846       "Pfam domain"
\& # file ends
.Ve
.PP
There are up to four columns of \s-1WHITESPACE \s0(not necessarily tab)
delimited text. Embedded whitespace must be escaped using shell
escaping rules (quoting the column or backslashing whitespace).
.PP
.Vb 2
\&  Column 1: The feature type. You may use type:subtype as a convention
\&            for method:source.
\&
\&  Column 2: The feature name/ID.
\&
\&  Column 3: The position of this feature in base pair
\&            coordinates. Ranges can be given as either 
\&            start\-end or start..end. A chromosome position
\&            can be specified using the format "reference:start..end".
\&            A discontinuous feature can be specified by giving
\&            multiple ranges separated by commas. Minus\-strand features
\&            are indicated by specifying a start > end.
\&
\&  Column 4: Comment/attribute field. A single Note can be given, or
\&            a series of attribute=value pairs, separated by
\&            spaces or semicolons, as in "score=23;type=transmembrane"
.Ve
.SS "Specifying Positions and Ranges"
.IX Subsection "Specifying Positions and Ranges"
A feature position is specified using a sequence \s-1ID \s0(a genbank
accession number, a chromosome name, a contig, or any other meaningful
reference system, followed by a colon and a position range. Ranges are
two integers separated by double dots or the hyphen. Examples:
\&\*(L"Chr1:516..11208\*(R", \*(L"ctgA:1\-5000\*(R". Negative coordinates are allowed, as
in \*(L"Chr1:\-187..1000\*(R".
.PP
A discontinuous range (\*(L"split location\*(R") uses commas to separate the
ranges.  For example:
.PP
.Vb 1
\& Gene B0511.1  Chr1:516..619,3185..3294,10946..11208
.Ve
.PP
In the case of a split location, the sequence id only has to appear in
front of the first range.
.PP
Alternatively, a split location can be indicated by repeating the
features type and name on multiple adjacent lines:
.PP
.Vb 3
\& Gene   B0511.1 Chr1:516..619
\& Gene   B0511.1 Chr1:3185..3294
\& Gene   B0511.1 Chr1:10946..11208
.Ve
.PP
If all the locations are on the same reference sequence, you can
specify a default chromosome using a \*(L"reference=<seqid>\*(R":
.PP
.Vb 4
\& reference=Chr1
\& Gene   B0511.1 516..619
\& Gene   B0511.1 3185..3294
\& Gene   B0511.1 10946..11208
.Ve
.PP
The default seqid is in effect until the next \*(L"reference\*(R" line
appears.
.SS "Feature Tags"
.IX Subsection "Feature Tags"
Tags can be added to features by adding a fourth column consisting of
\&\*(L"tag=value\*(R" pairs:
.PP
.Vb 1
\& Gene  B0511.1  Chr1:516..619,3185..3294 Note="Putative primase"
.Ve
.PP
Tags and their values take any form you want, and multiple tags can be
separated by semicolons. You can also repeat tags multiple times:
.PP
.Vb 1
\& Gene  B0511.1  Chr1:516..619,3185..3294 GO_Term=GO:100;GO_Term=GO:2087
.Ve
.PP
Several tags have special meanings:
.PP
.Vb 2
\& Tag     Meaning
\& \-\-\-     \-\-\-\-\-\-\-
\&
\& Type    The primary tag for a subfeature.
\& Score   The score of a feature or subfeature.
\& Phase   The phase of a feature or subfeature.
\& URL     A URL to link to (via the Bio::Graphics library).
\& Note    A note to attach to the feature for display by the Bio::Graphics library.
.Ve
.PP
For example, in the common case of an mRNA, you can use the \*(L"Type\*(R" tag
to distinguish the parts of the mRNA into \s-1UTR\s0 and \s-1CDS:\s0
.PP
.Vb 3
\& mRNA B0511.1 Chr1:1..100 Type=UTR
\& mRNA B0511.1 Chr1:101..200,300..400,500..800 Type=CDS
\& mRNA B0511.1 Chr1:801..1000 Type=UTR
.Ve
.PP
The top level feature's primary tag will be \*(L"mRNA\*(R", and its subparts
will have types \s-1UTR\s0 and \s-1CDS\s0 as indicated. Additional tags that are
placed in the first line of the feature will be applied to the top
level. In this example, the note \*(L"Putative primase\*(R" will be applied to
the mRNA at the top level of the feature:
.PP
.Vb 3
\& mRNA B0511.1 Chr1:1..100 Type=UTR;Note="Putative primase"
\& mRNA B0511.1 Chr1:101..200,300..400,500..800 Type=CDS
\& mRNA B0511.1 Chr1:801..1000 Type=UTR
.Ve
.SS "Feature Groups"
.IX Subsection "Feature Groups"
Features can be grouped so that they are rendered by the \*(L"group\*(R"
glyph.  To start a group, create a two-column feature entry showing
the group type and a name for the group.  Follow this with a list of
feature entries with a blank type.  For example:
.PP
.Vb 3
\& EST    yk53c10
\&        yk53c10.3       15000\-15500,15700\-15800
\&        yk53c10.5       18892\-19154
.Ve
.PP
This example is declaring that the ESTs named yk53c10.3 and yk53c10.5
belong to the same group named yk53c10.
.SS "Comments and the #include Directive"
.IX Subsection "Comments and the #include Directive"
Lines that begin with the # sign are treated as comments and
ignored. When a # sign appears within a line, everything to the right
of the symbol is also ignored, unless it looks like an \s-1HTML\s0 fragment or
an \s-1HTML\s0 color, e.g.:
.PP
.Vb 5
\& # this is ignored
\& [Example]
\& glyph   = generic   # this comment is ignored
\& bgcolor = #FF0000
\& link    = http://www.google.com/search?q=$name#results
.Ve
.PP
Be careful, because the processing of # signs uses a regexp heuristic. To be safe, 
always put a space after the # sign to make sure it is treated as a comment.
.PP
The special comment \*(L"#include 'filename'\*(R" acts like the C preprocessor
directive and will insert the comments of a named file into the
position at which it occurs. Relative paths will be treated relative
to the file in which the #include occurs. Nested #include directives
are allowed:
.PP
.Vb 3
\& #include "/usr/local/share/my_directives.txt"
\& #include \*(Aqmy_directives.txt\*(Aq
\& #include chromosome3_features.gff3
.Ve
.PP
You can enclose the file path in single or double quotes as shown
above. If there are no spaces in the filename the quotes are optional.
.PP
Include file processing is not very smart. Avoid creating circular
#include references. You have been warned!
.SS "Caveats"
.IX Subsection "Caveats"
Note that this loader always creates denormalized features such that
subfeatures and their parents are stored as one big database
object. The \s-1GFF3\s0 format and its loader is usually preferred for both
space and execution efficiency.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : $loader = Bio::DB::SeqFeature::Store::FeatureFileLoader\->new(@options)
\& Function: create a new parser
\& Returns : a Bio::DB::SeqFeature::Store::FeatureFileLoader parser and loader
\& Args    : several \- see below
\& Status  : public
.Ve
.PP
This method creates a new FeatureFile loader and establishes its connection
with a Bio::DB::SeqFeature::Store database. Arguments are \-name=>$value
pairs as described in this table:
.PP
.Vb 2
\& Name               Value
\& \-\-\-\-               \-\-\-\-\-
\&
\& \-store             A writable Bio::DB::SeqFeature::Store database handle.
\&
\& \-seqfeature_class  The name of the type of Bio::SeqFeatureI object to create
\&                      and store in the database (Bio::DB::SeqFeature by default)
\&
\& \-sf_class          A shorter alias for \-seqfeature_class
\&
\& \-verbose           Send progress information to standard error.
\&
\& \-fast              If true, activate fast loading (see below)
\&
\& \-chunk_size        Set the storage chunk size for nucleotide/protein sequences
\&                       (default 2000 bytes)
\&
\& \-tmp               Indicate a temporary directory to use when loading non\-normalized
\&                       features.
.Ve
.PP
When you call \fInew()\fR, a connection to a Bio::DB::SeqFeature::Store
database should already have been established and the database
initialized (if appropriate).
.PP
Some combinations of Bio::SeqFeatures and Bio::DB::SeqFeature::Store
databases support a fast loading mode. Currently the only reliable
implementation of fast loading is the combination of DBI::mysql with
Bio::DB::SeqFeature. The other important restriction on fast loading
is the requirement that a feature that contains subfeatures must occur
in the FeatureFile file before any of its subfeatures. Otherwise the
subfeatures that occurred before the parent feature will not be
attached to the parent correctly. This restriction does not apply to
normal (slow) loading.
.PP
If you use an unnormalized feature class, such as
Bio::SeqFeature::Generic, then the loader needs to create a temporary
database in which to cache features until all their parts and subparts
have been seen. This temporary databases uses the \*(L"bdb\*(R" adaptor. The
\&\-tmp option specifies the directory in which that database will be
created. If not present, it defaults to the system default tmp
directory specified by File::Spec\->\fItmpdir()\fR.
.PP
The \-chunk_size option allows you to tune the representation of
DNA/Protein sequence in the Store database. By default, sequences are
split into 2000 base/residue chunks and then reassembled as
needed. This avoids the problem of pulling a whole chromosome into
memory in order to fetch a short subsequence from somewhere in the
middle. Depending on your usage patterns, you may wish to tune this
parameter using a chunk size that is larger or smaller than the
default.
.SS "load"
.IX Subsection "load"
.Vb 6
\& Title   : load
\& Usage   : $count = $loader\->load(@ARGV)
\& Function: load the indicated files or filehandles
\& Returns : number of feature lines loaded
\& Args    : list of files or filehandles
\& Status  : public
.Ve
.PP
Once the loader is created, invoke its \fIload()\fR method with a list of
FeatureFile or \s-1FASTA\s0 file paths or previously-opened filehandles in order to
load them into the database. Compressed files ending with .gz, .Z and
\&.bz2 are automatically recognized and uncompressed on the fly. Paths
beginning with http: or ftp: are treated as URLs and opened using the
\&\s-1LWP GET\s0 program (which must be on your path).
.PP
\&\s-1FASTA\s0 files are recognized by their initial \*(L">\*(R" character. Do not feed
the loader a file that is neither FeatureFile nor \s-1FASTA\s0; I don't know what
will happen, but it will probably not be what you expect.
.SS "accessors"
.IX Subsection "accessors"
The following read-only accessors return values passed or created during \fInew()\fR:
.PP
.Vb 1
\& store()          the long\-term Bio::DB::SeqFeature::Store object
\&
\& tmp_store()      the temporary Bio::DB::SeqFeature::Store object used
\&                    during loading
\&
\& sfclass()        the Bio::SeqFeatureI class
\&
\& fast()           whether fast loading is active
\&
\& seq_chunk_size() the sequence chunk size
\&
\& verbose()        verbose progress messages
.Ve
.SS "default_seqfeature_class"
.IX Subsection "default_seqfeature_class"
.Vb 1
\&  $class = $loader\->default_seqfeature_class
.Ve
.PP
Return the default SeqFeatureI class (Bio::Graphics::Feature).
.SS "load_fh"
.IX Subsection "load_fh"
.Vb 1
\&  $count = $loader\->load_fh($filehandle)
.Ve
.PP
Load the FeatureFile data at the other end of the filehandle and return true
if successful. Internally, \fIload_fh()\fR invokes:
.PP
.Vb 3
\&  start_load();
\&  do_load($filehandle);
\&  finish_load();
.Ve
.SS "start_load, finish_load"
.IX Subsection "start_load, finish_load"
These methods are called at the start and end of a filehandle load.
.SS "load_line"
.IX Subsection "load_line"
.Vb 1
\&    $loader\->load_line($data);
.Ve
.PP
Load a line of a FeatureFile file. You must bracket this with calls to
\&\fIstart_load()\fR and \fIfinish_load()\fR!
.PP
.Vb 3
\&    $loader\->start_load();
\&    $loader\->load_line($_) while <FH>;
\&    $loader\->finish_load();
.Ve
.SS "handle_meta"
.IX Subsection "handle_meta"
.Vb 1
\&  $loader\->handle_meta($meta_directive)
.Ve
.PP
This method is called to handle meta-directives such as
##sequence\-region. The method will receive the directive with the
initial ## stripped off.
.SS "handle_feature"
.IX Subsection "handle_feature"
.Vb 1
\&  $loader\->handle_feature($gff3_line)
.Ve
.PP
This method is called to process a single FeatureFile line. It manipulates
information stored a data structure called \f(CW$self\fR\->{load_data}.
.SS "store_current_feature"
.IX Subsection "store_current_feature"
.Vb 1
\&  $loader\->store_current_feature()
.Ve
.PP
This method is called to store the currently active feature in the
database. It uses a data structure stored in \f(CW$self\fR\->{load_data}.
.SS "build_object_tree"
.IX Subsection "build_object_tree"
.Vb 1
\& $loader\->build_object_tree()
.Ve
.PP
This method gathers together features and subfeatures and builds the
graph that connects them.
.SS "build_object_tree_in_tables"
.IX Subsection "build_object_tree_in_tables"
.Vb 1
\& $loader\->build_object_tree_in_tables()
.Ve
.PP
This method gathers together features and subfeatures and builds the
graph that connects them, assuming that parent/child relationships
will be stored in a database table.
.SS "build_object_tree_in_features"
.IX Subsection "build_object_tree_in_features"
.Vb 1
\& $loader\->build_object_tree_in_features()
.Ve
.PP
This method gathers together features and subfeatures and builds the
graph that connects them, assuming that parent/child relationships are
stored in the seqfeature objects themselves.
.SS "attach_children"
.IX Subsection "attach_children"
.Vb 1
\& $loader\->attach_children($store,$load_data,$load_id,$feature)
.Ve
.PP
This recursively adds children to features and their subfeatures. It
is called when subfeatures are directly contained within other
features, rather than stored in a relational table.
.SS "parse_attributes"
.IX Subsection "parse_attributes"
.Vb 1
\& @attributes = $loader\->parse_attributes($attribute_line)
.Ve
.PP
This method parses the information contained in the \f(CW$attribute_line\fR
into a flattened hash (array). It may return one element, in which case it is
an implicit
.SS "start_or_finish_sequence"
.IX Subsection "start_or_finish_sequence"
.Vb 1
\&  $loader\->start_or_finish_sequence(\*(AqChr9\*(Aq)
.Ve
.PP
This method is called at the beginning and end of a fasta section.
.SH "BUGS"
.IX Header "BUGS"
This is an early version, so there are certainly some bugs. Please
use the BioPerl bug tracking system to report bugs.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::DB::SeqFeature::Store,
Bio::DB::SeqFeature::Segment,
Bio::DB::SeqFeature::NormalizedFeature,
Bio::DB::SeqFeature::GFF3Loader,
Bio::DB::SeqFeature::Store::DBI::mysql,
Bio::DB::SeqFeature::Store::bdb
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2006 Cold Spring Harbor Laboratory.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
