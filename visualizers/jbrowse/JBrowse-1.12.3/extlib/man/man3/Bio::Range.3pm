.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Range 3"
.TH Bio::Range 3 "2018-10-02" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Range \- Pure perl RangeI implementation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  $range = Bio::Range\->new(\-start=>10, \-end=>30, \-strand=>+1);
\&  $r2 = Bio::Range\->new(\-start=>15, \-end=>200, \-strand=>+1);
\&
\&  print join(\*(Aq, \*(Aq, $range\->union($r2)), "\en";
\&  print join(\*(Aq, \*(Aq, $range\->intersection($r2)), "\en";
\&
\&  print $range\->overlaps($r2), "\en";
\&  print $range\->contains($r2), "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This provides a pure perl implementation of the BioPerl range
interface.
.PP
Ranges are modeled as having (start, end, length, strand). They use
Bio-coordinates \- all points >= start and <= end are within the
range. End is always greater-than or equal-to start, and length is
greather than or equal to 1. The behaviour of a range is undefined if
ranges with negative numbers or zero are used.
.PP
So, in summary:
.PP
.Vb 3
\&  length = end \- start + 1
\&  end >= start
\&  strand = (\-1 | 0 | +1)
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via  the web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Heikki Lehvaslaiho"
.IX Header "AUTHOR - Heikki Lehvaslaiho"
Email heikki-at-bioperl-dot-org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SH "Constructors"
.IX Header "Constructors"
.SS "new"
.IX Subsection "new"
.Vb 6
\&  Title   : new
\&  Usage   : $range = Bio::Range\->new(\-start => 100, \-end=> 200, \-strand = +1);
\&  Function: generates a new Bio::Range
\&  Returns : a new range
\&  Args    : \-strand (defaults to 0) and any two of (\-start, \-end, \-length),
\&            the third will be calculated
.Ve
.SS "unions"
.IX Subsection "unions"
.Vb 6
\& Title   : unions
\& Usage   : @unions = Bio::Range\->unions(@ranges);
\& Function: generate a list of non\-intersecting Bio::Range objects
\&           from a list of Bio::Range objects which may intersect
\& Returns : a list of Bio::Range objects
\& Args    : a list of Bio::Range objects
.Ve
.SH "Member variable access"
.IX Header "Member variable access"
These methods let you get at and set the member variables
.SS "start"
.IX Subsection "start"
.Vb 6
\&  Title    : start
\&  Function : return or set the start co\-ordinate
\&  Example  : $s = $range\->start(); $range\->start(7);
\&  Returns  : the value of the start co\-ordinate
\&  Args     : optionally, the new start co\-ordinate
\&  Overrides: Bio::RangeI::start
.Ve
.SS "end"
.IX Subsection "end"
.Vb 6
\&  Title    : end
\&  Function : return or set the end co\-ordinate
\&  Example  : $e = $range\->end(); $range\->end(2000);
\&  Returns  : the value of the end co\-ordinate
\&  Args     : optionally, the new end co\-ordinate
\&  Overrides: Bio::RangeI::end
.Ve
.SS "strand"
.IX Subsection "strand"
.Vb 6
\&  Title    : strand
\&  Function : return or set the strandedness
\&  Example  : $st = $range\->strand(); $range\->strand(\-1);
\&  Returns  : the value of the strandedness (\-1, 0 or 1)
\&  Args     : optionally, the new strand \- (\-1, 0, 1) or (\-, ., +).
\&  Overrides: Bio::RangeI::strand
.Ve
.SS "length"
.IX Subsection "length"
.Vb 6
\&  Title    : length
\&  Function : returns the length of this range
\&  Example  : $length = $range\->length();
\&  Returns  : the length of this range, equal to end \- start + 1
\&  Args     : if you attempt to set the length an exception will be thrown
\&  Overrides: Bio::RangeI::Length
.Ve
.SS "toString"
.IX Subsection "toString"
.Vb 4
\&  Title   : toString
\&  Function: stringifies this range
\&  Example : print $range\->toString(), "\en";
\&  Returns : a string representation of this range
.Ve
.SH "Boolean Methods"
.IX Header "Boolean Methods"
These methods return true or false.
.PP
.Vb 1
\& $range\->overlaps($otherRange) && print "Ranges overlap\en";
.Ve
.SS "overlaps"
.IX Subsection "overlaps"
.Vb 6
\&  Title    : overlaps
\&  Usage    : if($r1\->overlaps($r2)) { do stuff }
\&  Function : tests if $r2 overlaps $r1
\&  Args     : a range to test for overlap with
\&  Returns  : true if the ranges overlap, false otherwise
\&  Inherited: Bio::RangeI
.Ve
.SS "contains"
.IX Subsection "contains"
.Vb 6
\&  Title    : contains
\&  Usage    : if($r1\->contains($r2) { do stuff }
\&  Function : tests whether $r1 totally contains $r2
\&  Args     : a range to test for being contained
\&  Returns  : true if the argument is totally contained within this range
\&  Inherited: Bio::RangeI
.Ve
.SS "equals"
.IX Subsection "equals"
.Vb 6
\&  Title    : equals
\&  Usage    : if($r1\->equals($r2))
\&  Function : test whether $r1 has the same start, end, length as $r2
\&  Args     : a range to test for equality
\&  Returns  : true if they are describing the same range
\&  Inherited: Bio::RangeI
.Ve
.SH "Geometrical methods"
.IX Header "Geometrical methods"
These methods do things to the geometry of ranges, and return
triplets (start, end, strand) from which new ranges could be built.
.SS "intersection"
.IX Subsection "intersection"
.Vb 6
\&  Title    : intersection
\&  Usage    : ($start, $stop, $strand) = $r1\->intersection($r2)
\&  Function : gives the range that is contained by both ranges
\&  Args     : a range to compare this one to
\&  Returns  : nothing if they do not overlap, or the range that they do overlap
\&  Inherited: Bio::RangeI::intersection
.Ve
.SS "union"
.IX Subsection "union"
.Vb 7
\&  Title    : union
\&  Usage    : ($start, $stop, $strand) = $r1\->union($r2);
\&           : ($start, $stop, $strand) = Bio::Range\->union(@ranges);
\&  Function : finds the minimal range that contains all of the ranges
\&  Args     : a range or list of ranges
\&  Returns  : the range containing all of the ranges
\&  Inherited: Bio::RangeI::union
.Ve
